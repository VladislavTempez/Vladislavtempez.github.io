<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr">
<head>
<!-- 2024-09-09 Mon 16:42 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Quelques exercices de programmation</title>
<meta name="author" content="Vladislav Tempez" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'left',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'left',
      displayIndent: '5em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'left',
      displayIndent: '5em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Quelques exercices de programmation</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table des matières</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgab3d815">Extremum d&rsquo;une liste&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></a></li>
<li><a href="#org952faea">Itérer sur les tableaux&#xa0;&#xa0;&#xa0;<span class="tag"><span class="tableau">tableau</span>&#xa0;<span class="imp_ratif">impératif</span>&#xa0;<span class="func">func</span></span></a></li>
<li><a href="#orgc163fa8">Comparer deux listes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></a></li>
<li><a href="#org76c5074">Inversion de liste&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></a></li>
<li><a href="#org799494d">Recherche dans un tableau&#xa0;&#xa0;&#xa0;<span class="tag"><span class="imp_ratif">impératif</span>&#xa0;<span class="tableau">tableau</span>&#xa0;<span class="ref">ref</span></span></a></li>
<li><a href="#org192774a">Décomposition en base \(b\)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></a></li>
<li><a href="#org71d1c68">Renversement d&rsquo;un tableau&#xa0;&#xa0;&#xa0;<span class="tag"><span class="tableau">tableau</span>&#xa0;<span class="imp_ratif">impératif</span></span></a></li>
<li><a href="#orgb79b5f8">Exponentiation rapide&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rec">rec</span></span></a></li>
<li><a href="#org04b4602">Image d&rsquo;un tableau&#xa0;&#xa0;&#xa0;<span class="tag"><span class="tableau">tableau</span>&#xa0;<span class="imp_ratif">impératif</span>&#xa0;<span class="func">func</span></span></a></li>
<li><a href="#orge14f6c5">Longueur d&rsquo;une liste&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></a></li>
<li><a href="#org0a0657c">Fusion triée&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></a></li>
<li><a href="#orga74df89">Produit matriciel&#xa0;&#xa0;&#xa0;<span class="tag"><span class="imp_ratif">impératif</span>&#xa0;<span class="matrice">matrice</span></span></a></li>
<li><a href="#org20a796b">Appartenance à une liste&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></a></li>
<li><a href="#org1578d3b">Image d&rsquo;une liste&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span>&#xa0;<span class="func">func</span></span></a></li>
<li><a href="#org13549b4">Somme si&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span>&#xa0;<span class="func">func</span></span></a></li>
<li><a href="#org1a8ba02">Indice du plus petit élément d&rsquo;une liste&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span>&#xa0;<span class="exception">exception</span></span></a></li>
<li><a href="#org689a8e3">Zip&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></a></li>
<li><a href="#orga5c249b">Renversement d&rsquo;un tableau en place&#xa0;&#xa0;&#xa0;<span class="tag"><span class="tableau">tableau</span>&#xa0;<span class="imp_ratif">impératif</span></span></a></li>
<li><a href="#org66f395a">Mémoïsation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="dictionnaire">dictionnaire</span>&#xa0;<span class="r_cursif">récursif</span></span></a></li>
<li><a href="#org37f802a">Nombre de Strahler&#xa0;&#xa0;&#xa0;<span class="tag"><span class="arbre">arbre</span>&#xa0;<span class="type_rec">type_rec</span></span></a></li>
<li><a href="#orgd3252c7">Chiffrement de César</a></li>
<li><a href="#org670f821">Compter les 0&#xa0;&#xa0;&#xa0;<span class="tag"><span class="dict">dict</span></span></a></li>
<li><a href="#orgb70347e">Découpage alterné de liste&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></a></li>
<li><a href="#orgb6268b3">Évaluation d&rsquo;un polynôme en un point (tableau)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="tableau">tableau</span>&#xa0;<span class="imp_ratif">impératif</span>&#xa0;<span class="r_f_rence">référence</span></span></a></li>
<li><a href="#orgd204f7f">Calcul de la dérivée d&rsquo;un polynôme (liste)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></a></li>
<li><a href="#org34ccfeb">Nombre de diviseurs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="imp_ratif">impératif</span>&#xa0;<span class="r_f_rence">référence</span>&#xa0;<span class="exception">exception</span></span></a></li>
<li><a href="#orgb0356a1">Expression arithmétique&#xa0;&#xa0;&#xa0;<span class="tag"><span class="type_rec">type_rec</span>&#xa0;<span class="arbre">arbre</span>&#xa0;<span class="option">option</span></span></a></li>
<li><a href="#orgbdd6603">Exponentiation rapide&#xa0;&#xa0;&#xa0;<span class="tag"><span class="imp_ratif">impératif</span>&#xa0;<span class="r_f_rence">référence</span></span></a></li>
<li><a href="#org38aa0cb">Bon parenthésage (impératif)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="imp_ratif">impératif</span>&#xa0;<span class="r_f_rence">référence</span></span></a></li>
<li><a href="#orgdbc93b0">Bon parenthésage multiple&#xa0;&#xa0;&#xa0;<span class="tag"><span class="Stack">Stack</span></span></a></li>
<li><a href="#org34b262c">Somme impaire&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></a></li>
<li><a href="#org20b6204">Hauteur d&rsquo;un arbre ternaire&#xa0;&#xa0;&#xa0;<span class="tag"><span class="type_rec">type_rec</span></span></a></li>
<li><a href="#org50ac458">Liste aplatie&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></a></li>
<li><a href="#orgd140292">Produit scalaire (tableau)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="imp_ratif">impératif</span>&#xa0;<span class="tableau">tableau</span>&#xa0;<span class="r_f_rence">référence</span></span></a></li>
<li><a href="#org71a68fb">Briser les chaînes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></a></li>
<li><a href="#org9be9482">Découpage régulier de liste&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></a></li>
<li><a href="#org14caf46">Tri par insertion&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></a></li>
<li><a href="#orgd08fad3">Filtrage d&rsquo;une liste&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span>&#xa0;<span class="func">func</span></span></a></li>
<li><a href="#org910e65a">Inversion de liste (impératif)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="imp_ratif">impératif</span>&#xa0;<span class="r_f_rence">référence</span></span></a></li>
<li><a href="#org205d3b9">Évaluation d&rsquo;un polynôme en un point (liste)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></a></li>
<li><a href="#org82094a0">Fusion alternée&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></a></li>
<li><a href="#orga2babd6">Deuxième max d&rsquo;une liste&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span>&#xa0;<span class="option">option</span></span></a></li>
<li><a href="#org3421a6d">PGCD d&rsquo;une liste&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></a></li>
<li><a href="#org0533045">Simplification de fraction&#xa0;&#xa0;&#xa0;<span class="tag"><span class="enregistrement">enregistrement</span></span></a></li>
<li><a href="#org334b35c">Itérer sur une liste&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span>&#xa0;<span class="func">func</span></span></a></li>
<li><a href="#org64e0643">Recherche dichotomique&#xa0;&#xa0;&#xa0;<span class="tag"><span class="imp_ratif">impératif</span>&#xa0;<span class="tableau">tableau</span>&#xa0;<span class="option">option</span>&#xa0;<span class="r_f_rence">référence</span></span></a></li>
<li><a href="#org7c93433">k-accessibles&#xa0;&#xa0;&#xa0;<span class="tag"><span class="imp_ratif">impératif</span>&#xa0;<span class="tableau">tableau</span>&#xa0;<span class="liste">liste</span>&#xa0;<span class="rec">rec</span>&#xa0;<span class="r_f_rence">référence</span></span></a></li>
<li><a href="#org946e018">Recherche de mot dans un texte&#xa0;&#xa0;&#xa0;<span class="tag"><span class="imp_ratif">impératif</span>&#xa0;<span class="r_f_rence">référence</span>&#xa0;<span class="option">option</span></span></a></li>
<li><a href="#org75b2ba8">Recherche dans un Arbre Binaire de recherche&#xa0;&#xa0;&#xa0;<span class="tag"><span class="type_rec">type_rec</span>&#xa0;<span class="option">option</span></span></a></li>
<li><a href="#org5179bce">Produit scalaire (liste)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></a></li>
<li><a href="#org6d64052">PGCD et PPCM&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rec">rec</span></span></a></li>
<li><a href="#org735ad4f">Insertion dans un Arbre Binaire de recherche&#xa0;&#xa0;&#xa0;<span class="tag"><span class="type_rec">type_rec</span></span></a></li>
<li><a href="#org42e2b91">Rotation de matrice&#xa0;&#xa0;&#xa0;<span class="tag"><span class="imp_ratif">impératif</span>&#xa0;<span class="matrice">matrice</span></span></a></li>
<li><a href="#org1783ffd">Subset sum&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rec">rec</span>&#xa0;<span class="liste">liste</span></span></a></li>
<li><a href="#org55afcba">Position du plus grand mot&#xa0;&#xa0;&#xa0;<span class="tag"><span class="imp_rarif">impérarif</span>&#xa0;<span class="r_f_rence">référence</span></span></a></li>
<li><a href="#org3200a2a">Palindrome&#xa0;&#xa0;&#xa0;<span class="tag"><span class="imp_ratif">impératif</span>&#xa0;<span class="r_f_rence">référence</span></span></a></li>
<li><a href="#org8968dbd">Remerciements</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgab3d815" class="outline-2">
<h2 id="orgab3d815">Extremum d&rsquo;une liste&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></h2>
<div class="outline-text-2" id="text-orgab3d815">
</div>
<div id="outline-container-orgcce255a" class="outline-3">
<h3 id="orgcce255a">Énoncé</h3>
<div class="outline-text-3" id="text-orgcce255a">
<p>
Implémenter deux fonctions <code>min_lst</code> et <code>max_lst</code> dont l&rsquo;appel sur une liste non vide s&rsquo;évalue en le min et le max des éléments de cette liste. Sur une liste vide, une exception sera levée.
Par exemple <code>min_list [0;1;2;3]</code> s&rsquo;évalue en <code>0</code>.
</p>
</div>
</div>
<div id="outline-container-org968f356" class="outline-3 spoiler">
<h3 id="org968f356">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org968f356">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">min_lst</span> <span style="color: #6a1868;">lst</span> =
  <span style="color: #e45649;">match</span> lst <span style="color: #e45649;">with</span>
  |<span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; <span style="color: #a626a4;">failwith</span> <span style="color: #50a14f;">"Empty list"</span>
  |[x] -&gt; x
  |head<span style="color: #383a42; background-color: #fafafa;">::</span>tail -&gt; min head (min_lst tail)
<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">max_lst</span> <span style="color: #6a1868;">lst</span> =
  <span style="color: #e45649;">match</span> lst <span style="color: #e45649;">with</span>
  |<span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; <span style="color: #a626a4;">failwith</span> <span style="color: #50a14f;">"Empty list"</span>
  |[x] -&gt; x
  |head<span style="color: #383a42; background-color: #fafafa;">::</span>tail -&gt; max head (max_lst tail)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org952faea" class="outline-2">
<h2 id="org952faea">Itérer sur les tableaux&#xa0;&#xa0;&#xa0;<span class="tag"><span class="tableau">tableau</span>&#xa0;<span class="imp_ratif">impératif</span>&#xa0;<span class="func">func</span></span></h2>
<div class="outline-text-2" id="text-org952faea">
</div>
<div id="outline-container-orge62b5cc" class="outline-3">
<h3 id="orge62b5cc">Énoncé</h3>
<div class="outline-text-3" id="text-orge62b5cc">
<p>
Implémenter une fonction <code>array_iter</code> prenant en entier une fonction à effet de bord (<code>'a -&gt; unit'</code> ) et appliquant cette fonction successivement à tous les éléments d&rsquo;un tableau passé en argument en commençant au premier élément.
</p>

<p>
Par exemple <code>array_iter (fun x -&gt; print_int x) [|1;2;3|]</code> affichera <code>123</code>.
</p>

<p>
Cette fonction réplique le comportement de la fonction <code>Array.iter</code> du module <code>Array</code> que vous n&rsquo;utilisez <b>pas</b> dans cet exercice.
</p>
</div>
</div>
<div id="outline-container-org30479ae" class="outline-3 spoiler">
<h3 id="org30479ae">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org30479ae">
<p>
Ici il suffit de parcourir le tableau via une boucle <code>for</code>. Attention aux dépassements d&rsquo;indice.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">array_iter</span> <span style="color: #6a1868;">f</span> <span style="color: #6a1868;">array</span> =
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">n</span> = <span style="color: #986801;">Array.</span>length array <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #e45649;">for</span> i = <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #e45649;">to</span> (n-<span style="color: #da8548; font-weight: bold;">1</span>) <span style="color: #e45649;">do</span>
    f (array.(i))
  <span style="color: #e45649;">done</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc163fa8" class="outline-2">
<h2 id="orgc163fa8">Comparer deux listes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></h2>
<div class="outline-text-2" id="text-orgc163fa8">
</div>
<div id="outline-container-org81353c7" class="outline-3">
<h3 id="org81353c7">Énoncé</h3>
<div class="outline-text-3" id="text-org81353c7">
<p>
Implémentez une fonction <code>is_greater</code> de comparaison <code>stricte</code> de liste s&rsquo;appuyant sur l&rsquo;ordre lexicographique (ordre du dictionnaire).
Par exemple <code>is_greater [] [1]</code> s&rsquo;évalue en <code>false</code>, <code>is_greater [1.2] [1.1; 1.5]</code> s&rsquo;évalue en <code>true</code> et <code>is_greater [1.1] [1.1; 1.5]</code> s&rsquo;évalue en <code>false</code>.
</p>
</div>
</div>
<div id="outline-container-orgc142d21" class="outline-3 spoiler">
<h3 id="orgc142d21">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-orgc142d21">
<p>
Il suffit de parcourir simultanément les deux listes et de s&rsquo;arrêter dès qu&rsquo;on trouve une bonne raison: soit une liste et vide, et l&rsquo;autre est plus grande, soit un des deux éléments de tête est plus grand que l&rsquo;autre. Si les deux sont vides, on doit renvoyer <code>false</code> car la comparaison est stricte.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">is_greater</span> <span style="color: #6a1868;">lst1</span> <span style="color: #6a1868;">lst2</span> =
  <span style="color: #e45649;">match</span> lst1, lst2 <span style="color: #e45649;">with</span>
  |<span style="color: #383a42; background-color: #fafafa;">[]</span>, _ -&gt; <span style="color: #b751b6;">false</span>
  |_, <span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; <span style="color: #b751b6;">true</span>
  |h1<span style="color: #383a42; background-color: #fafafa;">::</span>t1, h2<span style="color: #383a42; background-color: #fafafa;">::</span>t2 <span style="color: #e45649;">when</span> h1 &gt; h2 -&gt; <span style="color: #b751b6;">true</span>
  |h1<span style="color: #383a42; background-color: #fafafa;">::</span>t1, h2<span style="color: #383a42; background-color: #fafafa;">::</span>t2 <span style="color: #e45649;">when</span> h1 &lt; h2 -&gt; <span style="color: #b751b6;">false</span>
  |h1<span style="color: #383a42; background-color: #fafafa;">::</span>t1, h2<span style="color: #383a42; background-color: #fafafa;">::</span>t2 -&gt; is_greater t1 t2
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org76c5074" class="outline-2">
<h2 id="org76c5074">Inversion de liste&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></h2>
<div class="outline-text-2" id="text-org76c5074">
</div>
<div id="outline-container-orgdc965fb" class="outline-3">
<h3 id="orgdc965fb">Énoncé</h3>
<div class="outline-text-3" id="text-orgdc965fb">
<p>
Implémenter une fonction <code>rev</code> dont l&rsquo;appel sur une liste s&rsquo;évalue en cette liste dont l&rsquo;ordre des éléments a été changé.
Par exemple <code>rev [0;1;2;3]</code> s&rsquo;évalue en <code>[3;2;1;0]</code>.
</p>
</div>
</div>
<div id="outline-container-org6161719" class="outline-3 spoiler">
<h3 id="org6161719">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org6161719">
<p>
Le principe est de travailler avec une liste contenant ce qui a déjà été inversé (le début de la liste déjà traité, ici <code>already_done_lst</code>). Ensuite, on place en tête de cette liste le premier élément de la liste à traiter, puis on traite la suite de la liste, qui sera donc placée devant l&rsquo;élément qu&rsquo;on vient de traiter.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">rev_with_acc</span> <span style="color: #6a1868;">lst</span> <span style="color: #6a1868;">already_done_lst</span> =
  <span style="color: #e45649;">match</span> lst <span style="color: #e45649;">with</span>
  |<span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; already_done_lst
  |head<span style="color: #383a42; background-color: #fafafa;">::</span>tail -&gt; rev_with_acc tail (head<span style="color: #383a42; background-color: #fafafa;">::</span>already_done_lst)
<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">rev</span> <span style="color: #6a1868;">lst</span> = rev_with_acc lst <span style="color: #383a42; background-color: #fafafa;">[]</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org799494d" class="outline-2">
<h2 id="org799494d">Recherche dans un tableau&#xa0;&#xa0;&#xa0;<span class="tag"><span class="imp_ratif">impératif</span>&#xa0;<span class="tableau">tableau</span>&#xa0;<span class="ref">ref</span></span></h2>
<div class="outline-text-2" id="text-org799494d">
</div>
<div id="outline-container-org6fe3f7f" class="outline-3">
<h3 id="org6fe3f7f">Énoncé</h3>
<div class="outline-text-3" id="text-org6fe3f7f">
<p>
Implémentez une fonction <code>array_mem</code> qui s&rsquo;évalue à vrai si un tableau passé en argument contient un élément passé en argument.
Par exemple <code>array_mem 5 [|1;2;3|]</code> s&rsquo;évalue en <code>false</code> et <code>array_mem [|3;5;6|]</code> s&rsquo;évalue en <code>true</code>.
</p>

<p>
Cette fonction réplique le comportement de la fonction <code>Array.mem</code> du module <code>Array</code> que vous n&rsquo;utilisez <b>pas</b> dans cet exercice.
</p>
</div>
</div>
<div id="outline-container-org9ae7f2f" class="outline-3 spoiler">
<h3 id="org9ae7f2f">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org9ae7f2f">
<p>
On parcourt le tableau, si jamais on trouve <code>e</code>, on passe la référence <code>result</code> à <code>true</code>. Attention ici, pas de <code>return</code> et la boucle <code>for</code> ira à son terme.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">array_mem</span> <span style="color: #6a1868;">e</span> <span style="color: #6a1868;">array</span> =
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">result</span> = <span style="color: #a626a4;">ref</span> <span style="color: #b751b6;">false</span> <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">n</span> = <span style="color: #986801;">Array.</span>length array <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #e45649;">for</span> i = <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #e45649;">to</span> (n-<span style="color: #da8548; font-weight: bold;">1</span>) <span style="color: #e45649;">do</span>
    result := <span style="color: #a52a2a;">!</span>result <span style="color: #a52a2a;">||</span> (array.(i) = e)
  <span style="color: #e45649;">done</span>;
  <span style="color: #a52a2a;">!</span>result
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org192774a" class="outline-2">
<h2 id="org192774a">Décomposition en base \(b\)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></h2>
<div class="outline-text-2" id="text-org192774a">
</div>
<div id="outline-container-org3ced237" class="outline-3">
<h3 id="org3ced237">Énoncé</h3>
<div class="outline-text-3" id="text-org3ced237">
<p>
Implémentez une fonction <code>base_b</code> qui s&rsquo;évalue en la liste des coefficients de la décomposition en base \(b\) de son argument \(n\). Les coefficients de poids le plus faible seront en tête de liste.
Par exemple, <code>base_b 2 10</code> s&rsquo;évalue en <code>[0;1;0;1]</code> car \(10 = 2^1 + 2^3\).
</p>
</div>
</div>
<div id="outline-container-org95cee74" class="outline-3 spoiler">
<h3 id="org95cee74">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org95cee74">
<p>
On peut exploiter la relation de récurrence suivante: \(n = (n \text{ modulo } b) × 1 + b *(n/b)\) avec \(/\) la division entière. Le coefficient de poids faible est obtenu via le modulo, et les suivant via un appel récursif sur \(n/b\).
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">base_b</span> <span style="color: #6a1868;">b</span> <span style="color: #6a1868;">n</span> =
  <span style="color: #e45649;">if</span> n &lt; b <span style="color: #e45649;">then</span>
    [n]
  <span style="color: #e45649;">else</span>
    (n <span style="color: #a52a2a;">mod</span> b)<span style="color: #383a42; background-color: #fafafa;">::</span>(base_b b (n/b))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org71d1c68" class="outline-2">
<h2 id="org71d1c68">Renversement d&rsquo;un tableau&#xa0;&#xa0;&#xa0;<span class="tag"><span class="tableau">tableau</span>&#xa0;<span class="imp_ratif">impératif</span></span></h2>
<div class="outline-text-2" id="text-org71d1c68">
</div>
<div id="outline-container-orgb6234ac" class="outline-3">
<h3 id="orgb6234ac">Énoncé</h3>
<div class="outline-text-3" id="text-orgb6234ac">
<p>
Implémenter une fonction <code>array_rev</code> prenant en entier un tableau <code>array</code> et s&rsquo;évaluant en un tableau <code>[|a.(n); a.(n-1); ...|]</code>
Par exemple <code>array_rev [|3;2;1|]</code> s&rsquo;évalue en <code>[|1;2;3|]</code>.
</p>
</div>
</div>
<div id="outline-container-orgf7d514b" class="outline-3 spoiler">
<h3 id="orgf7d514b">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-orgf7d514b">
<p>
Il faut initialiser un tableau résultat, le remplir avec une valeur du bon type puis une boucle for suffit pour remplir ce tableau par indice décroissant de <code>array</code>.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">array_rev</span> <span style="color: #6a1868;">array</span> =
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">n</span> = <span style="color: #986801;">Array.</span>length array <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">result</span> = <span style="color: #986801;">Array.</span>make n array.(n-<span style="color: #da8548; font-weight: bold;">1</span>) <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #e45649;">for</span> i = <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #e45649;">to</span> (n-<span style="color: #da8548; font-weight: bold;">1</span>) <span style="color: #e45649;">do</span>
    result.(i) &lt;- array.(n-<span style="color: #da8548; font-weight: bold;">1</span>-i)
  <span style="color: #e45649;">done</span>;
  result
</pre>
</div>
<p>
On peut aussi procéder via <code>Array.init</code> ou bien <code>Array.map</code>.
</p>
</div>
</div>
</div>
<div id="outline-container-orgb79b5f8" class="outline-2">
<h2 id="orgb79b5f8">Exponentiation rapide&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rec">rec</span></span></h2>
<div class="outline-text-2" id="text-orgb79b5f8">
</div>
<div id="outline-container-orgb9a0956" class="outline-3">
<h3 id="orgb9a0956">Énoncé</h3>
<div class="outline-text-3" id="text-orgb9a0956">
<p>
Implémentez une fonction <code>exp</code> qui prend deux entiers <code>a</code> et <code>n</code> et s&rsquo;évalue en \(a^n\).
La complexité sera en \(O(\log(n))\) et vous n&rsquo;utiliserez pas de boucle.
Par exemple <code>exp 5 3</code> s&rsquo;évalue en <code>125</code>
</p>
</div>
</div>
<div id="outline-container-org545397a" class="outline-3 spoiler">
<h3 id="org545397a">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org545397a">
<p>
Il s&rsquo;agit de l&rsquo;algorithme classique d&rsquo;exponentiation rapide. Attention à ne <b>pas</b> faire deux appels récursifs mais bien un seul dans le cas <code>n</code> pair, sinon tout les gain en complexité sont perdus puisque les calculs sont dupliqués.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">exp</span> <span style="color: #6a1868;">a</span> <span style="color: #6a1868;">n</span> =
  <span style="color: #e45649;">if</span> n = <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #e45649;">then</span>
    <span style="color: #da8548; font-weight: bold;">1</span>
  <span style="color: #e45649;">else</span> <span style="color: #e45649;">if</span> n <span style="color: #a52a2a;">mod</span> <span style="color: #da8548; font-weight: bold;">2</span> = <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #e45649;">then</span>
    exp (a*a) (n/<span style="color: #da8548; font-weight: bold;">2</span>)
  <span style="color: #e45649;">else</span>
    a * (exp a (n-<span style="color: #da8548; font-weight: bold;">1</span>))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org04b4602" class="outline-2">
<h2 id="org04b4602">Image d&rsquo;un tableau&#xa0;&#xa0;&#xa0;<span class="tag"><span class="tableau">tableau</span>&#xa0;<span class="imp_ratif">impératif</span>&#xa0;<span class="func">func</span></span></h2>
<div class="outline-text-2" id="text-org04b4602">
</div>
<div id="outline-container-org0669161" class="outline-3">
<h3 id="org0669161">Énoncé</h3>
<div class="outline-text-3" id="text-org0669161">
<p>
Implémenter une fonction <code>array_map</code> prenant en entrée une fonction <code>f</code> et un tableau <code>array</code> et s&rsquo;évaluant en un tableau <code>[|f array.(0); f array.(1); ...|]</code>
Par exemple <code>array_map (fun x -&gt; x + x) [|1;2;3|]</code> s&rsquo;évalue en <code>[|2;4;6|]</code>.
</p>

<p>
Cette fonction réplique le comportement de la fonction <code>Array.map</code> du module <code>Array</code> que vous n&rsquo;utilisez <b>pas</b> dans cet exercice.
</p>
</div>
</div>
<div id="outline-container-org9ff6808" class="outline-3 spoiler">
<h3 id="org9ff6808">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org9ff6808">
<p>
Ici il faut d&rsquo;abord créer le tableau résultat. Pour ça il faut obtenir une valeur initiale pour les cases dont le type doit être le même que celui des images de <code>f</code>. Une approche simple pour ceci consiste à évaluer <code>f</code> sur la première case du tableau <code>array</code>.
Il ne faut pas oublier de &laquo;&nbsp;renvoyer&nbsp;&raquo; de résultat obtenu.
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">array_map</span> <span style="color: #6a1868;">f</span> <span style="color: #6a1868;">array</span> =
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">n</span> = <span style="color: #986801;">Array.</span>length array <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">result</span> = <span style="color: #986801;">Array.</span>make n (f array.(<span style="color: #da8548; font-weight: bold;">0</span>)) <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #e45649;">for</span> i = <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #e45649;">to</span> (n-<span style="color: #da8548; font-weight: bold;">1</span>) <span style="color: #e45649;">do</span>
    result.(i) &lt;- f (array.(i))
  <span style="color: #e45649;">done</span>;
  result
</pre>
</div>

<p>
Ici, il était aussi possible d&rsquo;utiliser directement <code>Array.init</code> pour un code plus court.
</p>
</div>
</div>
</div>
<div id="outline-container-orge14f6c5" class="outline-2">
<h2 id="orge14f6c5">Longueur d&rsquo;une liste&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></h2>
<div class="outline-text-2" id="text-orge14f6c5">
</div>
<div id="outline-container-org5a0aafe" class="outline-3">
<h3 id="org5a0aafe">Énoncé</h3>
<div class="outline-text-3" id="text-org5a0aafe">
<p>
Implémentez une fonction <code>list_length</code> qui s&rsquo;évalue en la longueur d&rsquo;une liste passée en argument.
Par exemple <code>list_length [0;1;2]</code> s&rsquo;évalue en <code>3</code>.
</p>
</div>
</div>
<div id="outline-container-orga6d555b" class="outline-3 spoiler">
<h3 id="orga6d555b">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-orga6d555b">
<p>
Fonction classique.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">list_length</span> <span style="color: #6a1868;">lst</span> =
  <span style="color: #e45649;">match</span> lst <span style="color: #e45649;">with</span>
  |<span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; <span style="color: #da8548; font-weight: bold;">0</span>
  |head<span style="color: #383a42; background-color: #fafafa;">::</span>tail -&gt; <span style="color: #da8548; font-weight: bold;">1</span> + list_length tail
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org0a0657c" class="outline-2">
<h2 id="org0a0657c">Fusion triée&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></h2>
<div class="outline-text-2" id="text-org0a0657c">
</div>
<div id="outline-container-org55cedad" class="outline-3">
<h3 id="org55cedad">Énoncé</h3>
<div class="outline-text-3" id="text-org55cedad">
<p>
Implémentez une fonction <code>sorted_merge</code> qui fusionne les éléments de deux listes triées dans l&rsquo;ordre croissant en une seule liste triée.
</p>

<p>
Par exemple <code>sorted_merge [0;2;3;6] [1;4]</code> s&rsquo;évalue en <code>[0;1;2;3;4;6]</code>.
</p>
</div>
</div>
<div id="outline-container-org6bd12dd" class="outline-3 spoiler">
<h3 id="org6bd12dd">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org6bd12dd">
<p>
On parcourt simultanément les deux liste tant qu&rsquo;il reste des éléments, et on place en premier la plus petite des deux tête, puis on continue.
C&rsquo;est la <b>très</b> classique fusion du tri fusion.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">sorted_merge</span> <span style="color: #6a1868;">lst1</span> <span style="color: #6a1868;">lst2</span> =
  <span style="color: #e45649;">match</span> lst1,lst2 <span style="color: #e45649;">with</span>
  |<span style="color: #383a42; background-color: #fafafa;">[]</span>, lst | lst, <span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; lst
  |h1<span style="color: #383a42; background-color: #fafafa;">::</span>t1, h2<span style="color: #383a42; background-color: #fafafa;">::</span>t2 <span style="color: #e45649;">when</span> h1&lt; h2 -&gt; h1<span style="color: #383a42; background-color: #fafafa;">::</span>(sorted_merge t1 lst2)
  |h1<span style="color: #383a42; background-color: #fafafa;">::</span>t1, h2<span style="color: #383a42; background-color: #fafafa;">::</span>t2 -&gt; <span style="color: #9ca0a4;">(*</span><span style="color: #9ca0a4;">h2 &lt;= h1</span><span style="color: #9ca0a4;">*)</span> h2<span style="color: #383a42; background-color: #fafafa;">::</span>(sorted_merge lst1 t2)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orga74df89" class="outline-2">
<h2 id="orga74df89">Produit matriciel&#xa0;&#xa0;&#xa0;<span class="tag"><span class="imp_ratif">impératif</span>&#xa0;<span class="matrice">matrice</span></span></h2>
<div class="outline-text-2" id="text-orga74df89">
</div>
<div id="outline-container-org9298bb5" class="outline-3">
<h3 id="org9298bb5">Énoncé</h3>
<div class="outline-text-3" id="text-org9298bb5">
<p>
Implémentez une fonction <code>matrix_product</code> qui réalise le produit de deux matrices représentées par des <code>float array array</code> dont les dimensions conviennent.
</p>

<p>
Si les dimensions ne conviennent pas, une exception sera levée.
</p>

<p>
Par exemple <code>matrix_product [|[|1.; 0.|];[|0.; 1.|]|] [|[|5.; 6.|];[|7.; 8.|]|]</code> s&rsquo;évalue en <code>[|[|5.; 6.|];[|7.; 8.|]|]</code>
</p>
</div>
</div>
<div id="outline-container-org3f8a1f6" class="outline-3 spoiler">
<h3 id="org3f8a1f6">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org3f8a1f6">
<p>
Il faut initialiser une matrice qui contiendra le résultat, on peut pour cela utiliser <code>Array.make_matrix</code>.
Puis il suffit d&rsquo;appliquer la définition du produit matriciel via une triple boucle for.
</p>

<p>
Attention aux borne des boucles, en OCaml la borne supérieure est atteinte.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">matrix_product</span> <span style="color: #6a1868;">m1</span> <span style="color: #6a1868;">m2</span> =
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">l1</span> = <span style="color: #986801;">Array.</span>length m1 <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">c1</span> = <span style="color: #986801;">Array.</span>length m1.(<span style="color: #da8548; font-weight: bold;">0</span>) <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">l2</span> = <span style="color: #986801;">Array.</span>length m2 <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">c2</span> = <span style="color: #986801;">Array.</span>length m2.(<span style="color: #da8548; font-weight: bold;">0</span>) <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #e45649;">if</span> c1 &lt;&gt; l2 <span style="color: #e45649;">then</span>
    <span style="color: #a626a4;">failwith</span> <span style="color: #50a14f;">"Dimensions incorrectes"</span>
  <span style="color: #e45649;">else</span>
    <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">result</span> = <span style="color: #986801;">Array.</span>make_matrix l1 c2 <span style="color: #da8548; font-weight: bold;">0</span>. <span style="color: #000000; font-weight: bold;">in</span>
    <span style="color: #e45649;">for</span> i = <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #e45649;">to</span> l1-<span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #e45649;">do</span>
      <span style="color: #e45649;">for</span> j = <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #e45649;">to</span> c2-<span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #e45649;">do</span>
        <span style="color: #e45649;">for</span> k = <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #e45649;">to</span> c1-<span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #e45649;">do</span>
          result.(i).(j) &lt;- result.(i).(j) +. (m1.(i).(k) *. m2.(k).(j))
        <span style="color: #e45649;">done</span>
      <span style="color: #e45649;">done</span>
    <span style="color: #e45649;">done</span>;
    result
</pre>
</div>

<p>
On pourra se référer à l&rsquo;algorithme de Strassen si on souhaite une meilleur complexité pour la multiplication de matrices de grande dimension.
</p>
</div>
</div>
</div>
<div id="outline-container-org20a796b" class="outline-2">
<h2 id="org20a796b">Appartenance à une liste&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></h2>
<div class="outline-text-2" id="text-org20a796b">
</div>
<div id="outline-container-orgb8a7594" class="outline-3">
<h3 id="orgb8a7594">Énoncé</h3>
<div class="outline-text-3" id="text-orgb8a7594">
<p>
Implémenter une fonction <code>list_mem</code> prenant en entrée un élément <code>e</code> et une liste <code>lst</code> et déterminant si <code>e</code> est une élément de <code>lst</code>.
Par exemple <code>list_mem 5 [1;2;3]</code> s&rsquo;évalue en <code>false</code>.
</p>

<p>
Cette fonction réplique le comportement de la fonction <code>List.mem</code> du module <code>List</code> que vous n&rsquo;utilisez <b>pas</b> dans cet exercice.
</p>
</div>
</div>
<div id="outline-container-orga3f9a89" class="outline-3 spoiler">
<h3 id="orga3f9a89">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-orga3f9a89">
<p>
Il suffit de parcourir la liste et de renvoyer <code>true</code> si on trouve <code>e</code> et false si on arrive à la fin. Attention dans le <code>match</code> on redéfinit la valeur de <code>e</code> si on <code>écrit =e::tail</code>.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">list_mem</span> <span style="color: #6a1868;">e</span> <span style="color: #6a1868;">lst</span> =
   <span style="color: #e45649;">match</span> lst <span style="color: #e45649;">with</span>
   |<span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; <span style="color: #b751b6;">false</span>
   |head<span style="color: #383a42; background-color: #fafafa;">::</span>tail <span style="color: #e45649;">when</span> head = e -&gt; <span style="color: #b751b6;">true</span>
   |head<span style="color: #383a42; background-color: #fafafa;">::</span>tail <span style="color: #9ca0a4;">(* </span><span style="color: #9ca0a4;">head &lt;&gt; e</span><span style="color: #9ca0a4;"> *)</span>-&gt; list_mem e tail
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org1578d3b" class="outline-2">
<h2 id="org1578d3b">Image d&rsquo;une liste&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span>&#xa0;<span class="func">func</span></span></h2>
<div class="outline-text-2" id="text-org1578d3b">
</div>
<div id="outline-container-org7fdf066" class="outline-3">
<h3 id="org7fdf066">Énoncé</h3>
<div class="outline-text-3" id="text-org7fdf066">
<p>
Implémenter une fonction <code>list_map</code> prenant en entrée une fonction <code>f</code> et une liste <code>lst</code> et s&rsquo;évaluant en une liste des images des éléments de <code>lst</code> par <code>f</code>.
Par exemple <code>list_map (fun x -&gt; x + x) [1;2;3]</code> s&rsquo;évalue en <code>[2;4;6]</code>.
</p>

<p>
Cette fonction réplique le comportement de la fonction <code>List.map</code> du module <code>List</code> que vous n&rsquo;utilisez <b>pas</b> dans cet exercice.
</p>
</div>
</div>
<div id="outline-container-org5c336e2" class="outline-3 spoiler">
<h3 id="org5c336e2">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org5c336e2">
<p>
Il suffit de parcourir récursivement la liste et d&rsquo;appliquer <code>f</code> à tous les éléments rencontrés.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">list_map</span> <span style="color: #6a1868;">f</span> <span style="color: #6a1868;">lst</span> =
  <span style="color: #e45649;">match</span> lst <span style="color: #e45649;">with</span>
  |<span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; <span style="color: #383a42; background-color: #fafafa;">[]</span>
  |head<span style="color: #383a42; background-color: #fafafa;">::</span>tail -&gt; (f head)<span style="color: #383a42; background-color: #fafafa;">::</span>(list_map f tail)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org13549b4" class="outline-2">
<h2 id="org13549b4">Somme si&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span>&#xa0;<span class="func">func</span></span></h2>
<div class="outline-text-2" id="text-org13549b4">
</div>
<div id="outline-container-org28c6edd" class="outline-3">
<h3 id="org28c6edd">Énoncé</h3>
<div class="outline-text-3" id="text-org28c6edd">
<p>
On considère une liste d&rsquo;entiers <code>lst</code> et un prédicat sur les entiers <code>p</code>. Implémentez une fonction <code>sum_if</code> qui s&rsquo;évalue en la somme des éléments de la liste qui vérifient le prédicat.
Par exemple <code>sum_if (fun x -&gt; x mod 2 = 0) [1;3;5]</code> s&rsquo;évalue en <code>0</code>
</p>
</div>
</div>
<div id="outline-container-org62c398d" class="outline-3 spoiler">
<h3 id="org62c398d">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org62c398d">
<p>
On parcourt simplement la liste en vérifiant le prédicat avant de sommer.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">sum_if</span> <span style="color: #6a1868;">p</span> <span style="color: #6a1868;">lst</span> =
  <span style="color: #e45649;">match</span> lst <span style="color: #e45649;">with</span>
  |<span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; <span style="color: #da8548; font-weight: bold;">0</span>
  |head<span style="color: #383a42; background-color: #fafafa;">::</span>tail <span style="color: #e45649;">when</span> p head -&gt; head + sum_if p tail
  |head<span style="color: #383a42; background-color: #fafafa;">::</span>tail -&gt; sum_if p tail
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org1a8ba02" class="outline-2">
<h2 id="org1a8ba02">Indice du plus petit élément d&rsquo;une liste&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span>&#xa0;<span class="exception">exception</span></span></h2>
<div class="outline-text-2" id="text-org1a8ba02">
</div>
<div id="outline-container-org108481d" class="outline-3">
<h3 id="org108481d">Énoncé</h3>
<div class="outline-text-3" id="text-org108481d">
<p>
Implémentez une fonction <code>min_and_argmin</code> qui s&rsquo;évalue en un couple du plus petit élément d&rsquo;une liste et de son indice dans la liste. Dans le cas d&rsquo;une liste vide, une exception sera levée. Si la liste contient des doublons, <code>min_and_argmin</code> choisira le min avec l&rsquo;indice le plus faible.
</p>

<p>
Par exemple <code>min_and_argmin [1;2;5;0;7]</code> s&rsquo;évalue en <code>(0,3)</code>.
</p>

<p>
Vous n&rsquo;utiliserez pas de boucle.
</p>
</div>
</div>
<div id="outline-container-org523f1fd" class="outline-3 spoiler">
<h3 id="org523f1fd">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org523f1fd">
<p>
On introduit une fonction auxiliaire avec un argument supplémentaire pour indiquant l&rsquo;index courant dans la liste. On fait un cas particulier pour la liste vide <b>et</b> pour la liste à un seul élément pour éviter de systématiquement lever une exception.
</p>

<p>
Puis on appel cet fonction avec comme indice initial 0.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">min_and_argmin_with_rank</span> <span style="color: #6a1868;">current_index</span> <span style="color: #6a1868;">lst</span> =
  <span style="color: #e45649;">match</span> lst <span style="color: #e45649;">with</span>
  |<span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; <span style="color: #a626a4;">failwith</span> <span style="color: #50a14f;">"List vide"</span>
  |[x] -&gt; (current_index, x)
  |head<span style="color: #383a42; background-color: #fafafa;">::</span>tail -&gt; <span style="color: #e45649;">match</span> min_and_argmin_with_rank (current_index + <span style="color: #da8548; font-weight: bold;">1</span>) tail <span style="color: #e45649;">with</span>
                 |(value,index) <span style="color: #e45649;">when</span> value &gt;= head -&gt; (head, current_index)
                 |(value, index) <span style="color: #9ca0a4;">(* </span><span style="color: #9ca0a4;">head &gt; value</span><span style="color: #9ca0a4;"> *)</span>-&gt; (value,index)
<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">min_and_argmin</span> <span style="color: #6a1868;">lst</span> =
  min_and_argmin_with_rank <span style="color: #da8548; font-weight: bold;">0</span> lst
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org689a8e3" class="outline-2">
<h2 id="org689a8e3">Zip&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></h2>
<div class="outline-text-2" id="text-org689a8e3">
</div>
<div id="outline-container-org187b4cb" class="outline-3">
<h3 id="org187b4cb">Énoncé</h3>
<div class="outline-text-3" id="text-org187b4cb">
<p>
Implémentez une fonction <code>zip</code> qui prend en argument deux listes en s&rsquo;évalue en une liste des couples des éléments de même rang de ces deux listes. Si les listes sont de taille différente, une exception sera levée.
</p>

<p>
Par exemple <code>zip [1;2;3] [4;5;6]</code> s&rsquo;évalue en <code>[(1,4);(2,5);(3,6)]</code>.
</p>
</div>
</div>
<div id="outline-container-orgc2a232a" class="outline-3 spoiler">
<h3 id="orgc2a232a">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-orgc2a232a">
<p>
Il suffit de parcourir récursivement les deux listes.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">zip</span> <span style="color: #6a1868;">lst1</span> <span style="color: #6a1868;">lst2</span> =
  <span style="color: #e45649;">match</span> lst1, lst2 <span style="color: #e45649;">with</span>
  |<span style="color: #383a42; background-color: #fafafa;">[]</span>,<span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; <span style="color: #383a42; background-color: #fafafa;">[]</span>
  |<span style="color: #383a42; background-color: #fafafa;">[]</span>, _ | _, <span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; <span style="color: #a626a4;">failwith</span> <span style="color: #50a14f;">"Listes de taille diff&#233;rente"</span>
  |h1<span style="color: #383a42; background-color: #fafafa;">::</span>t1, h2<span style="color: #383a42; background-color: #fafafa;">::</span>t2 -&gt; (h1,h2)<span style="color: #383a42; background-color: #fafafa;">::</span>(zip t1 t2)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orga5c249b" class="outline-2">
<h2 id="orga5c249b">Renversement d&rsquo;un tableau en place&#xa0;&#xa0;&#xa0;<span class="tag"><span class="tableau">tableau</span>&#xa0;<span class="imp_ratif">impératif</span></span></h2>
<div class="outline-text-2" id="text-orga5c249b">
</div>
<div id="outline-container-org27c59a1" class="outline-3">
<h3 id="org27c59a1">Énoncé</h3>
<div class="outline-text-3" id="text-org27c59a1">
<p>
Implémenter une fonction <code>array_inplace_rev</code> prenant en entier un tableau <code>array</code> et inversant l&rsquo;ordre de ses cases.
Par exemple <code>array_inplace_rev [|3;2;1|]</code> modifiera le contenu du tableau en <code>[|1;2;3|]</code>.
</p>
</div>
</div>
<div id="outline-container-orgea4ac59" class="outline-3 spoiler">
<h3 id="orgea4ac59">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-orgea4ac59">
<p>
Il faut initialiser un tableau résultat, le remplir avec une valeur du bon type puis une boucle for suffit pour remplir ce tableau par indice décroissant de <code>array</code>.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">array_inplace_rev</span> <span style="color: #6a1868;">array</span> =
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">n</span> = <span style="color: #986801;">Array.</span>length array <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">temp_result</span> = <span style="color: #986801;">Array.</span>make n array.(n-<span style="color: #da8548; font-weight: bold;">1</span>) <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #e45649;">for</span> i = <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #e45649;">to</span> (n-<span style="color: #da8548; font-weight: bold;">1</span>) <span style="color: #e45649;">do</span>
    temp_result.(i) &lt;- array.(n-<span style="color: #da8548; font-weight: bold;">1</span>-i)
  <span style="color: #e45649;">done</span>;
  <span style="color: #e45649;">for</span> i = <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #e45649;">to</span> (n-<span style="color: #da8548; font-weight: bold;">1</span>) <span style="color: #e45649;">do</span>
    array.(i) &lt;- temp_result.(i)
  <span style="color: #e45649;">done</span>
</pre>
</div>
<p>
On pourrait s&rsquo;économiser la première boucle via <code>Array.init</code> ou <code>Array.map</code>. On pourrait utiliser moins de mémoire en faisant un échange des cases des extrémités. Attention à ne pas faire deux fois l&rsquo;échange en arrêtant la boucle pour <code>i = n/2</code>
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">array_inplace_rev</span> <span style="color: #6a1868;">array</span> =
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">n</span> = <span style="color: #986801;">Array.</span>length array <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #e45649;">for</span> i = <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #e45649;">to</span> (n/<span style="color: #da8548; font-weight: bold;">2</span>) <span style="color: #e45649;">do</span>
    <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">a_i</span> = array.(i) <span style="color: #000000; font-weight: bold;">in</span>
    array.(i) &lt;- array.(n-<span style="color: #da8548; font-weight: bold;">1</span>-i);
    array.(n-<span style="color: #da8548; font-weight: bold;">1</span>-i) &lt;- a_i
  <span style="color: #e45649;">done</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org66f395a" class="outline-2">
<h2 id="org66f395a">Mémoïsation&#xa0;&#xa0;&#xa0;<span class="tag"><span class="dictionnaire">dictionnaire</span>&#xa0;<span class="r_cursif">récursif</span></span></h2>
<div class="outline-text-2" id="text-org66f395a">
</div>
<div id="outline-container-org82d1cef" class="outline-3">
<h3 id="org82d1cef">Énoncé</h3>
<div class="outline-text-3" id="text-org82d1cef">
<p>
On considère la suite \(u_n\) définit récursivement pour \(n > 0\) par
</p>
<ul class="org-ul">
<li>\(u_{2n} = u_n\)</li>
<li>\(u_{2n+1} = u_{2n-1} + u_{n}\)</li>
<li>\(u_0 = 1\), \(u_1 = 1\)</li>
</ul>
<p>
Implémentez une fonction <code>u</code> s&rsquo;évaluant en le terme de rang <code>n</code> de la suite quand on lui passe <code>n</code> en argument. Pour minimiser le temps de calcul nécessaire tout en gardant une consommation mémoire raisonnable vous prendrez soit de mémoïser le calcul des termes nécessaires pour \(u_n\) à l&rsquo;aide d&rsquo;un dictionnaire tel qu&rsquo;implémenté par le module <code>Hashtbl</code> de la bibliothèque standard d&rsquo;OCaml.
Par exemple, \(u_{70} = 87\)
</p>
</div>
</div>
<div id="outline-container-org4f975cc" class="outline-3 spoiler">
<h3 id="org4f975cc">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org4f975cc">
<p>
On commence par écrire une fonction auxiliaire récursive qui s&rsquo;appuie sur un dictionnaire passé en argument pour mémoïser le calcul, ensuite on peut faire la fonction attendue qui va créer le dictionnaire nécessaire puis appeler la fonction auxiliaire en lui fournissant le dictionnaire attendu.
Avant de réaliser un calcul, on vérifiera dans la fonction auxiliaire que le résultat de ce calcul n&rsquo;est pas déjà stocké dans le dictionnaire, et après avoir réalisé un calcul, on ajoutera le résultat dans le dictionnaire.
On remarque que si \(n = 2k+1\), \(n-2 = 2k-1\) pour gérer le deuxième cas de la relation de récurrence.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">u_with_dict</span> <span style="color: #6a1868;">dict</span> <span style="color: #6a1868;">n</span> =
  <span style="color: #e45649;">match</span> n <span style="color: #e45649;">with</span>
  <span style="color: #9ca0a4;">(*</span><span style="color: #9ca0a4;">cas de base</span><span style="color: #9ca0a4;">*)</span>
  |<span style="color: #da8548; font-weight: bold;">0</span> -&gt; <span style="color: #da8548; font-weight: bold;">1</span>
  |<span style="color: #da8548; font-weight: bold;">1</span> -&gt; <span style="color: #da8548; font-weight: bold;">1</span>
  <span style="color: #9ca0a4;">(*</span><span style="color: #9ca0a4;">si on connait d&#233;j&#224; le r&#233;sultat, on le renvoie</span><span style="color: #9ca0a4;">*)</span>
  |n <span style="color: #e45649;">when</span> <span style="color: #986801;">Hashtbl.</span>mem dict n -&gt; <span style="color: #986801;">Hashtbl.</span>find dict n
  <span style="color: #9ca0a4;">(*</span><span style="color: #9ca0a4;">Sinon, on calcule le r&#233;sultat, on l'ajoute au dictionnaire et on le renvoie</span><span style="color: #9ca0a4;">*)</span>
  |n <span style="color: #e45649;">when</span> n <span style="color: #a52a2a;">mod</span> <span style="color: #da8548; font-weight: bold;">2</span> = <span style="color: #da8548; font-weight: bold;">0</span> -&gt;
    <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">u_k</span> = u_with_dict dict (n/<span style="color: #da8548; font-weight: bold;">2</span>) <span style="color: #000000; font-weight: bold;">in</span>
    <span style="color: #986801;">Hashtbl.</span>add dict n u_k; u_k
  |n -&gt; <span style="color: #9ca0a4;">(*</span><span style="color: #9ca0a4;">n mod 2 = 1 ici</span><span style="color: #9ca0a4;"> *)</span>
    <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">u_k</span> = u_with_dict dict ((n-<span style="color: #da8548; font-weight: bold;">1</span>)/<span style="color: #da8548; font-weight: bold;">2</span>) <span style="color: #000000; font-weight: bold;">and</span>
        <span style="color: #6a1868;">u_2k_minus_1</span> = u_with_dict dict (n-<span style="color: #da8548; font-weight: bold;">2</span>) <span style="color: #000000; font-weight: bold;">in</span>
          <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">r</span> = (u_k + u_2k_minus_1) <span style="color: #000000; font-weight: bold;">in</span>
            (<span style="color: #986801;">Hashtbl.</span>add dict n r; r)

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">u</span> <span style="color: #6a1868;">n</span> =
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">d</span> = <span style="color: #986801;">Hashtbl.</span>create <span style="color: #da8548; font-weight: bold;">5</span> <span style="color: #000000; font-weight: bold;">in</span>
  u_with_dict d n
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org37f802a" class="outline-2">
<h2 id="org37f802a">Nombre de Strahler&#xa0;&#xa0;&#xa0;<span class="tag"><span class="arbre">arbre</span>&#xa0;<span class="type_rec">type_rec</span></span></h2>
<div class="outline-text-2" id="text-org37f802a">
</div>
<div id="outline-container-org792c2a7" class="outline-3">
<h3 id="org792c2a7">Énoncé</h3>
<div class="outline-text-3" id="text-org792c2a7">
<p>
On s&rsquo;intéresse à des arbres d&rsquo;arité non bornée, implémentés de la manière suivante:
</p>
<ul class="org-ul">
<li>Soit une feuille</li>
<li>Soit un nœud contenant une liste de fils</li>
</ul>
<p>
On suppose que les arbres sont implémentés par le type OCaml suivant:
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #986801;">tree</span> = <span style="color: #383a42; background-color: #fafafa;">Leaf</span> | <span style="color: #383a42; background-color: #fafafa;">Node</span> <span style="color: #e45649;">of</span> tree list
</pre>
</div>
<p>
Ici, on pourra considérer qu&rsquo;un nœud qui n&rsquo;est pas une feuille a au moins un fils, donc la liste associée n&rsquo;est pas vide.
Le nombre de Strahler d&rsquo;un arbre \(t\), noté $s(t)est défini inductivement de la manière suivante:
</p>
<ul class="org-ul">
<li>\(s(t) = 1\) si \(t\) est une feuille</li>
<li>\(s(t)\) est le plus grand nombre de Strahler des enfants de \(t\) si un de ces enfants possède un nombre de Strahler plus grand que tous les autres</li>
<li>\(s(t)\) est 1 + le plus grand nombre de Strahler des enfants de \(t\) si au moins deux enfants ont un plus grand nombre de Strahler que tous les autres.</li>
</ul>
<p>
Par exemple l&rsquo;arbre <code>t = Node ([Node ([Leaf; Leaf]); Leaf; Leaf])</code> a un nombre de Strahler de 2.
Implémenter une fonction <code>strahler</code> qui calcule le nombre de Strahler d&rsquo;un arbre.
</p>
</div>
</div>
<div id="outline-container-org9b1ccf2" class="outline-3 spoiler">
<h3 id="org9b1ccf2">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org9b1ccf2">
<p>
On commence par implémenter une fonction calculant le nombre de Strahler d&rsquo;un arbre dont on connait le nombre de Strahler des enfants. Pour cela on parcourt la liste des nombres de Strahler des enfants, en renvoie le max et le nombre d&rsquo;occurrences de ce max.
</p>

<p>
Ensuite, on peut implémenter la fonction <code>strahler</code> en calculant d&rsquo;abord le nombre de Strahler des enfants d&rsquo;un nœud puis en utilisant la fonction recherchant le max pour en déduire le nombre de Strahler du nœud.
On peut obtenir la liste des nombre de Strahler des enfants via l&rsquo;utilisation de la fonction <code>List.map</code>.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">get_max_and_max_occurrences</span> <span style="color: #6a1868;">strahler_children</span> =
  <span style="color: #e45649;">match</span> strahler_children <span style="color: #e45649;">with</span>
  |<span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; <span style="color: #a626a4;">failwith</span> <span style="color: #50a14f;">"Should be a Leaf"</span>
  |[x] -&gt; (x,<span style="color: #da8548; font-weight: bold;">1</span>)
  |head<span style="color: #383a42; background-color: #fafafa;">::</span>tail -&gt; <span style="color: #000000; font-weight: bold;">let</span> (<span style="color: #6a1868;">max</span>,<span style="color: #6a1868;">max_occ</span>) = get_max_and_max_occurrences tail <span style="color: #000000; font-weight: bold;">in</span>
                 <span style="color: #e45649;">if</span> max &gt; head <span style="color: #e45649;">then</span>
                   (max,max_occ)
                 <span style="color: #e45649;">else</span> <span style="color: #e45649;">if</span> max = head <span style="color: #e45649;">then</span>
                   (max,<span style="color: #da8548; font-weight: bold;">1</span>+max_occ)
                 <span style="color: #e45649;">else</span>
                   (head, <span style="color: #da8548; font-weight: bold;">1</span>)
<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">strahler</span> <span style="color: #6a1868;">t</span> =
  <span style="color: #e45649;">match</span> t <span style="color: #e45649;">with</span>
  |<span style="color: #383a42; background-color: #fafafa;">Leaf</span> -&gt; <span style="color: #da8548; font-weight: bold;">1</span>
  |<span style="color: #383a42; background-color: #fafafa;">Node</span> children -&gt; <span style="color: #000000; font-weight: bold;">let</span> (<span style="color: #6a1868;">max</span>, <span style="color: #6a1868;">max_occ</span>) = get_max_and_max_occurrences
                                           (<span style="color: #986801;">List.</span>map strahler children) <span style="color: #000000; font-weight: bold;">in</span>
                    <span style="color: #e45649;">if</span> max_occ &gt; <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #e45649;">then</span>
                      max +<span style="color: #da8548; font-weight: bold;">1</span>
                    <span style="color: #e45649;">else</span>
                      max
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd3252c7" class="outline-2">
<h2 id="orgd3252c7">Chiffrement de César</h2>
<div class="outline-text-2" id="text-orgd3252c7">
</div>
<div id="outline-container-orgdd44103" class="outline-3">
<h3 id="orgdd44103">Énoncé</h3>
<div class="outline-text-3" id="text-orgdd44103">
<p>
Le chiffrement de César consiste modifier le contenu d&rsquo;un message de manière en décalant chaque lettre d&rsquo;un nombre de positions fixe dans l&rsquo;alphabet. Par exemple, pour un décalage de 1, le mot &laquo;&nbsp;HAL&nbsp;&raquo; devient &laquo;&nbsp;IBM&nbsp;&raquo;.
Implémentez une fonction <code>caesar_encrypt</code> qui chiffre une chaîne de caractère représentant un message à l&rsquo;aide d&rsquo;une clé de décalage.
Par exemple <code>caesar_encrypt "HAL" 1</code> s&rsquo;évalue en <code>"IBM"</code>.
Attention, il vous est rappelé que les chaînes de caractère en OCaml sont immutables, il n&rsquo;est pas possible de modifier une chaîne.
Il est possible de convertir un caractère <code>c</code> en chaîne via <code>String.make 1 c</code>.
Seules les lettres seront modifiées, les autres caractères seront laissés inchangés, et la casse sera conservée. <code>caesar_encrypt "HaL" 1</code> s&rsquo;évalue en <code>"IbM"</code>.
</p>
</div>
</div>
<div id="outline-container-org7814b02" class="outline-3 spoiler">
<h3 id="org7814b02">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org7814b02">
<p>
Pour se simplifier la vie, on commence par implémenter une conversion de <code>string</code> vers <code>char list</code>.
Ensuite on implémente une fonction pour chiffrer un seul caractère.
Finalement, on implémente la conversion dans l&rsquo;autre sens pour l&rsquo;appliquer sur la liste des caractères chiffrés.
</p>

<p>
Attention aux modulos négatifs !
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">string_to_list_from_i</span> <span style="color: #6a1868;">s</span> <span style="color: #6a1868;">i</span> =
 <span style="color: #e45649;">if</span> i = <span style="color: #986801;">String.</span>length s <span style="color: #e45649;">then</span>
   <span style="color: #383a42; background-color: #fafafa;">[]</span>
  <span style="color: #e45649;">else</span>
   s.[i]<span style="color: #383a42; background-color: #fafafa;">::</span>(string_to_list_from_i s (i+<span style="color: #da8548; font-weight: bold;">1</span>))

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">string_to_list</span> <span style="color: #6a1868;">s</span> =
  string_to_list_from_i s <span style="color: #da8548; font-weight: bold;">0</span>

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">shift_letter</span> <span style="color: #6a1868;">k</span> <span style="color: #6a1868;">c</span> =
  <span style="color: #e45649;">if</span> (c &gt;= <span style="color: #50a14f;">'a'</span> <span style="color: #a52a2a;">&amp;&amp;</span> c &lt;= <span style="color: #50a14f;">'z'</span>) <span style="color: #e45649;">then</span>
    <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">x</span> = int_of_char c <span style="color: #000000; font-weight: bold;">in</span>
    <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">x_26</span> = x - (int_of_char <span style="color: #50a14f;">'a'</span>) <span style="color: #000000; font-weight: bold;">in</span>
    <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">new_x</span> = (x_26 + (k <span style="color: #a52a2a;">mod</span> <span style="color: #da8548; font-weight: bold;">26</span>) + <span style="color: #da8548; font-weight: bold;">26</span>) <span style="color: #a52a2a;">mod</span> <span style="color: #da8548; font-weight: bold;">26</span> + (int_of_char <span style="color: #50a14f;">'a'</span>) <span style="color: #000000; font-weight: bold;">in</span>
    char_of_int new_x
  <span style="color: #e45649;">else</span> <span style="color: #e45649;">if</span> (c &gt;= <span style="color: #50a14f;">'A'</span> <span style="color: #a52a2a;">&amp;&amp;</span> c &lt;= <span style="color: #50a14f;">'Z'</span>) <span style="color: #e45649;">then</span>
    <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">x</span> = int_of_char c <span style="color: #000000; font-weight: bold;">in</span>
    <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">x_26</span> = x - (int_of_char <span style="color: #50a14f;">'A'</span>) <span style="color: #000000; font-weight: bold;">in</span>
    <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">new_x</span> = (x_26 + (k <span style="color: #a52a2a;">mod</span> <span style="color: #da8548; font-weight: bold;">26</span>) + <span style="color: #da8548; font-weight: bold;">26</span>) <span style="color: #a52a2a;">mod</span> <span style="color: #da8548; font-weight: bold;">26</span> + (int_of_char <span style="color: #50a14f;">'A'</span>) <span style="color: #000000; font-weight: bold;">in</span>
    char_of_int new_x
  <span style="color: #e45649;">else</span>
    c

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">list_to_string</span> <span style="color: #6a1868;">lst</span> =
  <span style="color: #e45649;">match</span> lst <span style="color: #e45649;">with</span>
    |<span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; <span style="color: #50a14f;">""</span>
    |c<span style="color: #383a42; background-color: #fafafa;">::</span>t -&gt; (<span style="color: #986801;">String.</span>make <span style="color: #da8548; font-weight: bold;">1</span> c)<span style="color: #a52a2a;">^</span>(list_to_string t)

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">caesar_encrypt</span> <span style="color: #6a1868;">s</span> <span style="color: #6a1868;">k</span> =
  list_to_string  (<span style="color: #986801;">List.</span>map (shift_letter k) (string_to_list s))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org670f821" class="outline-2">
<h2 id="org670f821">Compter les 0&#xa0;&#xa0;&#xa0;<span class="tag"><span class="dict">dict</span></span></h2>
<div class="outline-text-2" id="text-org670f821">
</div>
<div id="outline-container-org6fce990" class="outline-3">
<h3 id="org6fce990">Énoncé</h3>
<div class="outline-text-3" id="text-org6fce990">
<p>
On s&rsquo;intéresse au nombre de 0 présents en fin d&rsquo;écriture décimale de \(n!\).
Implémentez une fonction qui compte ces 0. Vous éviterez de passer par le calcul direct de \(n!\) afin de ne pas vous exposer aux dépassent de capacité sur les entiers.
Afin de rendre la fonction aussi efficace que possible vous pourrez exploiter la relation \(n! = n × (n-1)!\) et le fait qu&rsquo;un 0 dans une écriture décimale correspond à l&rsquo;existence d&rsquo;un facteur \(10 = 2 × 5\) et vous mémoïserez les calculs intermédiaires.
</p>
</div>
</div>
<div id="outline-container-org5418935" class="outline-3 spoiler">
<h3 id="org5418935">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org5418935">
<p>
Pour savoir combien de facteur 10 possède \(n!\), il suffit de compter les facteurs 2 et 5, et de prendre le minimum des deux.
</p>

<p>
Pour faire cela, on exploite la relation de récurrence \(n! = n × (n-1)!\) et on fait donc un appel récursif avec \(n-1\) et un calcul du nombre de facteurs 2 et 5 dans \(n\).
</p>

<p>
C&rsquo;est le calcul du nombre de facteurs 2 et 5 dans \(n\) qui peut être mémoïsé en s&rsquo;appuyant sur le fait que le nombre de facteur \(k\) dans \(n\) est 1 + le nombre de facteurs \(k\) dans \(\frac{n}{k}\) si \(n\) est divisible par \(k\), et 0 sinon.
</p>

<p>
Par ailleurs, on peut décompter indépendamment les facteurs 2 et 5. On commence donc par implémenter une fonction pour compter les facteurs avec mémoïsation.
</p>

<p>
Par exemple, on pourra vérifier que 25! possède 6 0 en fin d&rsquo;écriture décimale.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">p_adic_val_memoisation</span> <span style="color: #6a1868;">dict</span> <span style="color: #6a1868;">n</span> <span style="color: #6a1868;">k</span> =
  <span style="color: #e45649;">if</span> n <span style="color: #a52a2a;">mod</span> k &gt; <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #e45649;">then</span>
    <span style="color: #da8548; font-weight: bold;">0</span>
  <span style="color: #e45649;">else</span> <span style="color: #e45649;">if</span> <span style="color: #986801;">Hashtbl.</span>mem dict n <span style="color: #e45649;">then</span>
    <span style="color: #986801;">Hashtbl.</span>find dict n
  <span style="color: #e45649;">else</span>
    <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">res</span> = <span style="color: #da8548; font-weight: bold;">1</span> + p_adic_val_memoisation dict (n/k) k <span style="color: #000000; font-weight: bold;">in</span>
    <span style="color: #986801;">Hashtbl.</span>add dict n res; res

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">p_adic_val_fact</span> <span style="color: #6a1868;">dict</span> <span style="color: #6a1868;">n</span> <span style="color: #6a1868;">k</span> =
  <span style="color: #e45649;">if</span> n = <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #e45649;">then</span>
    <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #9ca0a4;">(* </span><span style="color: #9ca0a4;">convention discutable ...</span><span style="color: #9ca0a4;"> *)</span>
  <span style="color: #e45649;">else</span> <span style="color: #e45649;">if</span> n = <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #e45649;">then</span>
    <span style="color: #da8548; font-weight: bold;">0</span>
  <span style="color: #e45649;">else</span>
    (p_adic_val_memoisation dict n k) + (p_adic_val_fact dict (n-<span style="color: #da8548; font-weight: bold;">1</span>) k )

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">count_0_fact</span> <span style="color: #6a1868;">n</span> =
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">dict_2</span> = <span style="color: #986801;">Hashtbl.</span>create <span style="color: #da8548; font-weight: bold;">10</span> <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">dict_5</span> = <span style="color: #986801;">Hashtbl.</span>create <span style="color: #da8548; font-weight: bold;">10</span> <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">_2_adic_val_fact</span> = p_adic_val_fact dict_2 n <span style="color: #da8548; font-weight: bold;">2</span> <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">_5_adic_val_fact</span> = p_adic_val_fact dict_5 n <span style="color: #da8548; font-weight: bold;">5</span> <span style="color: #000000; font-weight: bold;">in</span>
  min _2_adic_val_fact _5_adic_val_fact
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb70347e" class="outline-2">
<h2 id="orgb70347e">Découpage alterné de liste&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></h2>
<div class="outline-text-2" id="text-orgb70347e">
</div>
<div id="outline-container-orga5cd5e3" class="outline-3">
<h3 id="orga5cd5e3">Énoncé</h3>
<div class="outline-text-3" id="text-orga5cd5e3">
<p>
Implémentez une fonction <code>alternate_split_list</code> qui prend en argument une liste et s&rsquo;évalue en un couple de liste, la première contenant les éléments de rang pair et la seconde les éléments de rang impair. Vous n&rsquo;utiliserez pas de boucle dans cette fonction.
Par exemple <code>alternate_split_list [1;2;3]</code> s&rsquo;évaluera en <code>([1;3], [2])</code>
</p>
</div>
</div>
<div id="outline-container-orgfcec27c" class="outline-3 spoiler">
<h3 id="orgfcec27c">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-orgfcec27c">
<p>
On peut procéder via un filtrage en traitant les terme deux par deux, le premier étant de rang pair et le second de rang impair. Il suffit alors de les ajouter en tête des listes obtenues via un appel récursif sur la liste initial privée de ces deux éléments. Comme les éléments sont traités deux par deux, il faut un cas pour la liste vide <b>et</b> un cas pour la liste ne contenant qu&rsquo;un seul élément.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">alternate_split_list</span> <span style="color: #6a1868;">lst</span> =
  <span style="color: #e45649;">match</span> lst <span style="color: #e45649;">with</span>
  |<span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; (<span style="color: #383a42; background-color: #fafafa;">[]</span>,<span style="color: #383a42; background-color: #fafafa;">[]</span>)
  |[x] -&gt; ([x], <span style="color: #383a42; background-color: #fafafa;">[]</span>)
  |h1<span style="color: #383a42; background-color: #fafafa;">::</span>h2<span style="color: #383a42; background-color: #fafafa;">::</span>t -&gt; <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">even</span>,<span style="color: #6a1868;">odd</span> = alternate_split_list t <span style="color: #000000; font-weight: bold;">in</span>
                (h1<span style="color: #383a42; background-color: #fafafa;">::</span>even, h2<span style="color: #383a42; background-color: #fafafa;">::</span>odd)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb6268b3" class="outline-2">
<h2 id="orgb6268b3">Évaluation d&rsquo;un polynôme en un point (tableau)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="tableau">tableau</span>&#xa0;<span class="imp_ratif">impératif</span>&#xa0;<span class="r_f_rence">référence</span></span></h2>
<div class="outline-text-2" id="text-orgb6268b3">
</div>
<div id="outline-container-org9e3f11b" class="outline-3">
<h3 id="org9e3f11b">Énoncé</h3>
<div class="outline-text-3" id="text-org9e3f11b">
<p>
On considère un polynôme à coefficients <code>float</code> représenté par le tableau de ses coefficients. La case <code>i</code> contient le coefficient de degré <code>i</code>.
Implémentez une fonction <code>eval_at_array</code> qui prend ce polynôme et un flottant et évalue ce polynôme en ce flottant.
</p>

<p>
La complexité sera linéaire en le degré du polynôme.
</p>

<p>
Par exemple <code>eval_at_array [|5.;6.|] 1.</code> s&rsquo;évalue en <code>11.0</code>.
</p>
</div>
</div>
<div id="outline-container-orgb8d3993" class="outline-3 spoiler">
<h3 id="orgb8d3993">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-orgb8d3993">
<p>
Pour éviter les coûts liés aux calculs des puissances itérées, on peut calculer dans l&rsquo;orde \(x^0\) puis \(x^1\), puis \(x^2\) en temps constant à partir de la puissance précédente. Ici on accumule le résultat dans la référence <code>result</code>.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">eval_at_array</span> <span style="color: #6a1868;">p</span> <span style="color: #6a1868;">x</span> =
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">d</span> = <span style="color: #986801;">Array.</span>length p <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #9ca0a4;">(*</span><span style="color: #9ca0a4;">attention, ici d est le nombre de coefficients et non le degr&#233;</span><span style="color: #9ca0a4;">*)</span>
    <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">result</span> = <span style="color: #a626a4;">ref</span> <span style="color: #da8548; font-weight: bold;">0</span>. <span style="color: #000000; font-weight: bold;">in</span>
    <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">current_x_power</span> = <span style="color: #a626a4;">ref</span> <span style="color: #da8548; font-weight: bold;">1</span>. <span style="color: #000000; font-weight: bold;">in</span>
    <span style="color: #e45649;">for</span> i = <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #e45649;">to</span> (d-<span style="color: #da8548; font-weight: bold;">1</span>) <span style="color: #e45649;">do</span>
      result := <span style="color: #a52a2a;">!</span>result +. <span style="color: #a52a2a;">!</span>current_x_power *. p.(i);
      current_x_power := <span style="color: #a52a2a;">!</span>current_x_power *. x
    <span style="color: #e45649;">done</span> ;
    <span style="color: #a52a2a;">!</span>result
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd204f7f" class="outline-2">
<h2 id="orgd204f7f">Calcul de la dérivée d&rsquo;un polynôme (liste)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></h2>
<div class="outline-text-2" id="text-orgd204f7f">
</div>
<div id="outline-container-org545f249" class="outline-3">
<h3 id="org545f249">Énoncé</h3>
<div class="outline-text-3" id="text-org545f249">
<p>
On considère un polynôme à coefficients <code>float</code> représenté par la listes de ses coefficients. Le terme de rang <code>i</code> contient le coefficient de degré <code>i</code>.
Implémentez une fonction <code>diff_p_list</code> qui prend ce polynôme et un flottant et s&rsquo;évalue en la dérivée formelle de ce polynôme.
</p>

<p>
La complexité sera linéaire en le degré du polynôme.
</p>

<p>
Par exemple <code>diff_p_list [5.; 6.; 7.]</code> s&rsquo;évalue en <code>[6.; 14.]</code>.
</p>
</div>
</div>
<div id="outline-container-orgb1568f8" class="outline-3 spoiler">
<h3 id="orgb1568f8">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-orgb1568f8">
<p>
On commence par faire une fonction récursive qui multiplie chaque coefficient par une séquence de valeur consécutives (qui sont censés être le rang des coefficients).
</p>

<p>
Ensuite, on utilise cette fonction à partir du coefficient d&rsquo;ordre 1 et la première valeur associées (celle qui multiplie) sera donc aussi 1.
</p>

<p>
Il ne faut pas oublier de faire disparaitre le coefficient constant, décalant ainsi tous les termes pour bien réaliser une dérivée.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">diff_with_power</span> <span style="color: #6a1868;">lst</span> <span style="color: #6a1868;">current_power</span> =
  <span style="color: #e45649;">match</span> lst <span style="color: #e45649;">with</span>
    |<span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; <span style="color: #383a42; background-color: #fafafa;">[]</span>
    |head<span style="color: #383a42; background-color: #fafafa;">::</span>tail -&gt;
      (head *. current_power) <span style="color: #383a42; background-color: #fafafa;">::</span> (diff_with_power tail (current_power +. <span style="color: #da8548; font-weight: bold;">1</span>.))

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">diff_p_list</span> <span style="color: #6a1868;">p</span> =
  <span style="color: #e45649;">match</span> p <span style="color: #e45649;">with</span>
    |<span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; <span style="color: #383a42; background-color: #fafafa;">[]</span>
    |p_0<span style="color: #383a42; background-color: #fafafa;">::</span>p_next -&gt; diff_with_power (p_next) <span style="color: #da8548; font-weight: bold;">1.0</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org34ccfeb" class="outline-2">
<h2 id="org34ccfeb">Nombre de diviseurs&#xa0;&#xa0;&#xa0;<span class="tag"><span class="imp_ratif">impératif</span>&#xa0;<span class="r_f_rence">référence</span>&#xa0;<span class="exception">exception</span></span></h2>
<div class="outline-text-2" id="text-org34ccfeb">
</div>
<div id="outline-container-org738f180" class="outline-3">
<h3 id="org738f180">Énoncé</h3>
<div class="outline-text-3" id="text-org738f180">
<p>
Implémentez une fonction <code>div</code> qui calcule le nombre de diviseurs d&rsquo;un entier <code>n</code> donné.
</p>

<p>
Par exemple <code>div 5</code> s&rsquo;évalue en <code>2</code> (1 et 5).
</p>

<p>
Dans le cas \(n=0\), <code>div</code> lèvera une exception.
</p>
</div>
</div>
<div id="outline-container-org23248d9" class="outline-3 spoiler">
<h3 id="org23248d9">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org23248d9">
<p>
Il suffit de faire une boucle for
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">div</span> <span style="color: #6a1868;">n</span> =
  <span style="color: #e45649;">if</span> n = <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #e45649;">then</span>
    <span style="color: #a626a4;">failwith</span> <span style="color: #50a14f;">"tout le monde divise 0"</span>
  <span style="color: #e45649;">else</span>
    <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">result</span> = <span style="color: #a626a4;">ref</span> <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #000000; font-weight: bold;">in</span>
    <span style="color: #e45649;">for</span> i = <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #e45649;">to</span> n <span style="color: #e45649;">do</span>
      <span style="color: #e45649;">if</span> n <span style="color: #a52a2a;">mod</span> i = <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #e45649;">then</span>
        result := <span style="color: #a52a2a;">!</span>result +<span style="color: #da8548; font-weight: bold;">1</span>
    <span style="color: #e45649;">done</span>;
    <span style="color: #a52a2a;">!</span>result
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb0356a1" class="outline-2">
<h2 id="orgb0356a1">Expression arithmétique&#xa0;&#xa0;&#xa0;<span class="tag"><span class="type_rec">type_rec</span>&#xa0;<span class="arbre">arbre</span>&#xa0;<span class="option">option</span></span></h2>
<div class="outline-text-2" id="text-orgb0356a1">
</div>
<div id="outline-container-org1942440" class="outline-3">
<h3 id="org1942440">Énoncé</h3>
<div class="outline-text-3" id="text-org1942440">
<p>
On considère des expression arithmétiques représentées par le type suivant
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #986801;">expr</span> = <span style="color: #383a42; background-color: #fafafa;">Value</span> <span style="color: #e45649;">of</span> int
          | <span style="color: #383a42; background-color: #fafafa;">Plus</span> <span style="color: #e45649;">of</span> expr * expr
          | <span style="color: #383a42; background-color: #fafafa;">Minus</span> <span style="color: #e45649;">of</span> expr * expr
          | <span style="color: #383a42; background-color: #fafafa;">Product</span> <span style="color: #e45649;">of</span> expr * expr
          | <span style="color: #383a42; background-color: #fafafa;">Div</span> <span style="color: #e45649;">of</span> expr * expr
</pre>
</div>
<p>
Implémentez une fonction <code>eval_expr</code> qui évalue une telle expression.
Vous utiliserez un type option pour gérer le cas des expressions dont la valeur n&rsquo;est pas définie.
Par exemple <code>eval_expr (Plus (Value 1, Minus (Value 0, Value 1)))</code> s&rsquo;évalue en <code>Some 0</code> et <code>eval_expr (Div (Value 1, Value 0))</code> s&rsquo;évalue en <code>None</code>.
</p>
</div>
</div>
<div id="outline-container-org57c2910" class="outline-3 spoiler">
<h3 id="org57c2910">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org57c2910">
<p>
Il s&rsquo;agit de faire un parcours récursif de l&rsquo;arbre représentant l&rsquo;expression.
</p>

<p>
Il ne faut pas oublier de gérer les cas des expression qui non définies, qui se propagent vers le haut. Pour le faire, on évalue les sous expression, puis on fait un second filtrage pour gérer le cas d&rsquo;une des sous expression ayant une valeur non définie.
</p>

<p>
Pour la division, il faut aussi gérer le cas où le diviseur vaut 0, et dans ce cas, la division n&rsquo;est pas définie.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #986801;">expr</span> = <span style="color: #383a42; background-color: #fafafa;">Value</span> <span style="color: #e45649;">of</span> int
          | <span style="color: #383a42; background-color: #fafafa;">Plus</span> <span style="color: #e45649;">of</span> expr * expr
          | <span style="color: #383a42; background-color: #fafafa;">Minus</span> <span style="color: #e45649;">of</span> expr * expr
          | <span style="color: #383a42; background-color: #fafafa;">Product</span> <span style="color: #e45649;">of</span> expr * expr
          | <span style="color: #383a42; background-color: #fafafa;">Div</span> <span style="color: #e45649;">of</span> expr * expr

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">eval_expr</span> <span style="color: #6a1868;">e</span> =
  <span style="color: #e45649;">match</span> e <span style="color: #e45649;">with</span>
  |<span style="color: #383a42; background-color: #fafafa;">Value</span> i -&gt; <span style="color: #383a42; background-color: #fafafa;">Some</span> i
  |<span style="color: #383a42; background-color: #fafafa;">Plus</span> (e1, e2) -&gt;
    (<span style="color: #e45649;">match</span> (eval_expr e1, eval_expr e2) <span style="color: #e45649;">with</span>
       |_, <span style="color: #383a42; background-color: #fafafa;">None</span> | <span style="color: #383a42; background-color: #fafafa;">None</span>, _ -&gt; <span style="color: #383a42; background-color: #fafafa;">None</span>
       |<span style="color: #383a42; background-color: #fafafa;">Some</span> v1, <span style="color: #383a42; background-color: #fafafa;">Some</span> v2 -&gt; <span style="color: #383a42; background-color: #fafafa;">Some</span> (v1 + v2)
    )
  |<span style="color: #383a42; background-color: #fafafa;">Minus</span> (e1, e2) -&gt;
    (<span style="color: #e45649;">match</span> (eval_expr e1, eval_expr e2) <span style="color: #e45649;">with</span>
       |_, <span style="color: #383a42; background-color: #fafafa;">None</span> | <span style="color: #383a42; background-color: #fafafa;">None</span>, _ -&gt; <span style="color: #383a42; background-color: #fafafa;">None</span>
       |<span style="color: #383a42; background-color: #fafafa;">Some</span> v1, <span style="color: #383a42; background-color: #fafafa;">Some</span> v2 -&gt; <span style="color: #383a42; background-color: #fafafa;">Some</span> (v1 - v2)
    )
  |<span style="color: #383a42; background-color: #fafafa;">Product</span> (e1, e2) -&gt;
    (<span style="color: #e45649;">match</span> (eval_expr e1, eval_expr e2) <span style="color: #e45649;">with</span>
       |_, <span style="color: #383a42; background-color: #fafafa;">None</span> | <span style="color: #383a42; background-color: #fafafa;">None</span>, _ -&gt; <span style="color: #383a42; background-color: #fafafa;">None</span>
       |<span style="color: #383a42; background-color: #fafafa;">Some</span> v1, <span style="color: #383a42; background-color: #fafafa;">Some</span> v2 -&gt; <span style="color: #383a42; background-color: #fafafa;">Some</span> (v1 * v2)
    )
  |<span style="color: #383a42; background-color: #fafafa;">Div</span> (e1, e2) -&gt;
    (<span style="color: #e45649;">match</span> (eval_expr e1, eval_expr e2) <span style="color: #e45649;">with</span>
       |_, <span style="color: #383a42; background-color: #fafafa;">None</span> | <span style="color: #383a42; background-color: #fafafa;">None</span>, _ -&gt; <span style="color: #383a42; background-color: #fafafa;">None</span>
       |_, <span style="color: #383a42; background-color: #fafafa;">Some</span> <span style="color: #da8548; font-weight: bold;">0</span> -&gt; <span style="color: #383a42; background-color: #fafafa;">None</span>
       |<span style="color: #383a42; background-color: #fafafa;">Some</span> v1, <span style="color: #383a42; background-color: #fafafa;">Some</span> v2 -&gt; <span style="color: #383a42; background-color: #fafafa;">Some</span> (v1 / v2)
    )
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgbdd6603" class="outline-2">
<h2 id="orgbdd6603">Exponentiation rapide&#xa0;&#xa0;&#xa0;<span class="tag"><span class="imp_ratif">impératif</span>&#xa0;<span class="r_f_rence">référence</span></span></h2>
<div class="outline-text-2" id="text-orgbdd6603">
</div>
<div id="outline-container-org1936498" class="outline-3">
<h3 id="org1936498">Énoncé</h3>
<div class="outline-text-3" id="text-org1936498">
<p>
Implémentez une fonction <code>exp</code> qui prend deux entiers <code>a</code> et <code>n</code> et s&rsquo;évalue en \(a^n\).
La complexité sera en \(O(\log(n))\) et vous n&rsquo;utiliserez pas de fonction récursive.
Par exemple <code>exp 5 3</code> s&rsquo;évalue en <code>125</code>
</p>
</div>
</div>
<div id="outline-container-orgd0f3aa0" class="outline-3 spoiler">
<h3 id="orgd0f3aa0">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-orgd0f3aa0">
<p>
Il s&rsquo;agit de l&rsquo;algorithme classique d&rsquo;exponentiation rapide exploitant la relation \(a^{2n} = (a^2)^n\) et \(a^{2n+1} = a×a^{2n}\).
On peut vérifier la correction via l&rsquo;invariant de boucle <code>a^n = !result * !current_base ^current_power</code> avec en sortie <code>!current_power =0</code>
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">exp</span> <span style="color: #6a1868;">a</span> <span style="color: #6a1868;">n</span> =
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">result</span> = <span style="color: #a626a4;">ref</span> <span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">current_power</span> = <span style="color: #a626a4;">ref</span> n <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">current_base</span> = <span style="color: #a626a4;">ref</span> a <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #e45649;">while</span> <span style="color: #a52a2a;">!</span>current_power &gt; <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #e45649;">do</span>
    <span style="color: #e45649;">if</span> <span style="color: #a52a2a;">!</span>current_power <span style="color: #a52a2a;">mod</span> <span style="color: #da8548; font-weight: bold;">2</span> = <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #e45649;">then</span>
      (
        current_power := <span style="color: #a52a2a;">!</span>current_power /<span style="color: #da8548; font-weight: bold;">2</span>;
        current_base := <span style="color: #a52a2a;">!</span>current_base * <span style="color: #a52a2a;">!</span>current_base;
      )
    <span style="color: #e45649;">else</span> <span style="color: #9ca0a4;">(*</span><span style="color: #9ca0a4;">!current_power mod 2 = 1</span><span style="color: #9ca0a4;">*)</span>
      (
        result := <span style="color: #a52a2a;">!</span>result * <span style="color: #a52a2a;">!</span>current_base;
        current_power := <span style="color: #a52a2a;">!</span>current_power -<span style="color: #da8548; font-weight: bold;">1</span>;
      )
  <span style="color: #e45649;">done</span>;
  <span style="color: #a52a2a;">!</span>result
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org38aa0cb" class="outline-2">
<h2 id="org38aa0cb">Bon parenthésage (impératif)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="imp_ratif">impératif</span>&#xa0;<span class="r_f_rence">référence</span></span></h2>
<div class="outline-text-2" id="text-org38aa0cb">
</div>
<div id="outline-container-orge162c2a" class="outline-3">
<h3 id="orge162c2a">Énoncé</h3>
<div class="outline-text-3" id="text-orge162c2a">
<p>
On considère une chaîne de caractères ne contenant que des <code>'('</code> et <code>')'</code>.
Implémentez une fonction <code>is_well_braced</code> vérifiant s&rsquo;il s&rsquo;agit ou non d&rsquo;une expression bien parenthésée.
Par exemple <code>is_well_braced "()(())"</code> s&rsquo;évalue à <code>true</code>, mais <code>is_well_braced ")((())"</code> s&rsquo;évalue à <code>false</code>.
Vous n&rsquo;utiliserez pas de fonction récursive.
</p>
</div>
</div>
<div id="outline-container-org4d24070" class="outline-3 spoiler">
<h3 id="org4d24070">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org4d24070">
<p>
On s&rsquo;appuie sur le fait que dans une expression bien parenthésée, le nombre de parenthèses ouvrantes depuis le début est toujours supérieur ou égal à celui des parenthèses fermantes et qu&rsquo;à la fin, il y a autant de chaque paire.
On compte donc le nombre de chaque espèces rencontré jusque là tant qu&rsquo;on n&rsquo;a pas vu de problème (et qu&rsquo;on ne sort pas de la chaîne de caractères).
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">is_well_braced</span> <span style="color: #6a1868;">s</span> =
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">counter_open</span> = <span style="color: #a626a4;">ref</span> <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">counter_close</span> = <span style="color: #a626a4;">ref</span> <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">i</span> = <span style="color: #a626a4;">ref</span> <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #e45649;">while</span> <span style="color: #a52a2a;">!</span>counter_open &gt;= <span style="color: #a52a2a;">!</span>counter_close <span style="color: #a52a2a;">&amp;&amp;</span> (<span style="color: #a52a2a;">!</span>i &lt; <span style="color: #986801;">String.</span>length s) <span style="color: #e45649;">do</span>
    (<span style="color: #e45649;">if</span> s.[<span style="color: #a52a2a;">!</span>i] = <span style="color: #50a14f;">'('</span> <span style="color: #e45649;">then</span>
       counter_open := <span style="color: #a52a2a;">!</span>counter_open + <span style="color: #da8548; font-weight: bold;">1</span>
     <span style="color: #e45649;">else</span> <span style="color: #e45649;">if</span> s.[<span style="color: #a52a2a;">!</span>i] = <span style="color: #50a14f;">')'</span> <span style="color: #e45649;">then</span>
       counter_close := <span style="color: #a52a2a;">!</span>counter_close + <span style="color: #da8548; font-weight: bold;">1</span>
     <span style="color: #e45649;">else</span>
       <span style="color: #a626a4;">failwith</span> <span style="color: #50a14f;">"contient des caract&#232;res interdits"</span>);
    i := <span style="color: #a52a2a;">!</span>i+<span style="color: #da8548; font-weight: bold;">1</span>
  <span style="color: #e45649;">done</span>;
  <span style="color: #a52a2a;">!</span>counter_open = <span style="color: #a52a2a;">!</span>counter_close
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgdbc93b0" class="outline-2">
<h2 id="orgdbc93b0">Bon parenthésage multiple&#xa0;&#xa0;&#xa0;<span class="tag"><span class="Stack">Stack</span></span></h2>
<div class="outline-text-2" id="text-orgdbc93b0">
</div>
<div id="outline-container-org0864701" class="outline-3">
<h3 id="org0864701">Énoncé</h3>
<div class="outline-text-3" id="text-org0864701">
<p>
On considère une chaîne de caractères ne contenant que des caractères parmi <code>"()[]{}"</code>.
Implémentez une fonction <code>is_well_braced_multi</code> vérifiant s&rsquo;il s&rsquo;agit ou non d&rsquo;une expression bien parenthésée.
Par exemple <code>is_well_braced_multi "({})[]"</code> s&rsquo;évalue à <code>true</code>, mais <code>is_well_braced_multi "([)]{}"</code> s&rsquo;évalue à <code>false</code>.
Vous pourrez vous aider du module <code>Stack</code> de la bibliothèque standard OCaml.
</p>
</div>
</div>
<div id="outline-container-org7ab09c4" class="outline-3 spoiler">
<h3 id="org7ab09c4">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org7ab09c4">
<p>
Pour vérifier le bon parenthésage, on utilise une pile dans laquelle on entrepose chaque caractère ouvrant, et lorsqu&rsquo;on rencontre un caractère fermant, on vérifie que le caractère ouvrant du dessus de pile correspond bien au caractère fermant lu. Dans le cas contraire on sait que l&rsquo;expression n&rsquo;est pas bien parenthésée. En fin de parcours de l&rsquo;expression, on vérifie que la pile est bien vide.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">is_well_braced_multi</span> <span style="color: #6a1868;">s</span> =
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">current_open</span>  = <span style="color: #986801;">Stack.</span>create () <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">i</span> = <span style="color: #a626a4;">ref</span> <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">everything_ok_so_far</span> = <span style="color: #a626a4;">ref</span> <span style="color: #b751b6;">true</span> <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #e45649;">while</span> <span style="color: #a52a2a;">!</span>everything_ok_so_far <span style="color: #a52a2a;">&amp;&amp;</span> (<span style="color: #a52a2a;">!</span>i &lt; <span style="color: #986801;">String.</span>length s) <span style="color: #e45649;">do</span>
    (<span style="color: #e45649;">if</span> s.[<span style="color: #a52a2a;">!</span>i] = <span style="color: #50a14f;">'['</span> <span style="color: #a52a2a;">||</span> s.[<span style="color: #a52a2a;">!</span>i] = <span style="color: #50a14f;">'('</span> <span style="color: #a52a2a;">||</span> s.[<span style="color: #a52a2a;">!</span>i] = <span style="color: #50a14f;">'{'</span> <span style="color: #e45649;">then</span>
       <span style="color: #986801;">Stack.</span>push s.[<span style="color: #a52a2a;">!</span>i] current_open
     <span style="color: #e45649;">else</span> <span style="color: #e45649;">if</span> <span style="color: #a52a2a;">not</span> (<span style="color: #986801;">Stack.</span>is_empty current_open) <span style="color: #e45649;">then</span>
       <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">c</span> = <span style="color: #986801;">Stack.</span>pop current_open <span style="color: #000000; font-weight: bold;">in</span>
       <span style="color: #e45649;">if</span> s.[<span style="color: #a52a2a;">!</span>i] = <span style="color: #50a14f;">']'</span> <span style="color: #e45649;">then</span>
         everything_ok_so_far := <span style="color: #a52a2a;">!</span>everything_ok_so_far <span style="color: #a52a2a;">&amp;&amp;</span> (c = <span style="color: #50a14f;">'['</span>)
       <span style="color: #e45649;">else</span> <span style="color: #e45649;">if</span> s.[<span style="color: #a52a2a;">!</span>i] = <span style="color: #50a14f;">')'</span> <span style="color: #e45649;">then</span>
         everything_ok_so_far := <span style="color: #a52a2a;">!</span>everything_ok_so_far <span style="color: #a52a2a;">&amp;&amp;</span> (c = <span style="color: #50a14f;">'('</span>)
       <span style="color: #e45649;">else</span> <span style="color: #e45649;">if</span> s.[<span style="color: #a52a2a;">!</span>i] = <span style="color: #50a14f;">'}'</span> <span style="color: #e45649;">then</span>
         everything_ok_so_far := <span style="color: #a52a2a;">!</span>everything_ok_so_far <span style="color: #a52a2a;">&amp;&amp;</span> (c = <span style="color: #50a14f;">'{'</span>)
       <span style="color: #e45649;">else</span>
         <span style="color: #a626a4;">failwith</span> <span style="color: #50a14f;">"contient des caract&#232;res interdits"</span>
     <span style="color: #e45649;">else</span>
       everything_ok_so_far := <span style="color: #b751b6;">false</span>
    );
    i := <span style="color: #a52a2a;">!</span>i+<span style="color: #da8548; font-weight: bold;">1</span>
  <span style="color: #e45649;">done</span>;
  <span style="color: #a52a2a;">!</span>everything_ok_so_far <span style="color: #a52a2a;">&amp;&amp;</span> (<span style="color: #986801;">Stack.</span>is_empty current_open)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org34b262c" class="outline-2">
<h2 id="org34b262c">Somme impaire&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></h2>
<div class="outline-text-2" id="text-org34b262c">
</div>
<div id="outline-container-orgf694b85" class="outline-3">
<h3 id="orgf694b85">Énoncé</h3>
<div class="outline-text-3" id="text-orgf694b85">
<p>
On considère une liste d&rsquo;entiers <code>lst</code>. Implémentez une fonction <code>sum_odd</code> qui s&rsquo;évalue en la somme des éléments de la liste de rang impair.
Par exemple <code>sum_odd [1;3;5]</code> s&rsquo;évalue en <code>3</code>
</p>
</div>
</div>
<div id="outline-container-orge562d37" class="outline-3 spoiler">
<h3 id="orge562d37">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-orge562d37">
<p>
On parcourt simplement la liste en ne prenant pas le premier terme à chaque fois. Le décalage de 2 en 2 assure que le second terme est toujours de rang impair. Il ne faut pas oublier de gérer le cas de la liste à un seul élément et celui de la liste vide vu qu&rsquo;on progresse de 2 éléments en 2 éléments.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">sum_odd</span> <span style="color: #6a1868;">lst</span> =
  <span style="color: #e45649;">match</span> lst <span style="color: #e45649;">with</span>
  |<span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; <span style="color: #da8548; font-weight: bold;">0</span>
  |[x] -&gt; <span style="color: #da8548; font-weight: bold;">0</span>
  |h1<span style="color: #383a42; background-color: #fafafa;">::</span>h2<span style="color: #383a42; background-color: #fafafa;">::</span>tail -&gt; h2 + (sum_odd tail)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org20b6204" class="outline-2">
<h2 id="org20b6204">Hauteur d&rsquo;un arbre ternaire&#xa0;&#xa0;&#xa0;<span class="tag"><span class="type_rec">type_rec</span></span></h2>
<div class="outline-text-2" id="text-org20b6204">
</div>
<div id="outline-container-org5cd3f9d" class="outline-3">
<h3 id="org5cd3f9d">Énoncé</h3>
<div class="outline-text-3" id="text-org5cd3f9d">
<p>
On considère des arbres ternaires implémentés via le type suivant:
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #986801;">ternary_tree</span> = <span style="color: #383a42; background-color: #fafafa;">Leaf</span> | <span style="color: #383a42; background-color: #fafafa;">Node</span> <span style="color: #e45649;">of</span> ternary_tree * ternary_tree * ternary_tree
</pre>
</div>
<p>
Implémentez une fonction <code>tree_height</code> qui s&rsquo;évalue en la hauteur d&rsquo;un tel arbre. Par exemple
</p>
<div class="org-src-container">
<pre class="src src-ocaml">tree_height (<span style="color: #383a42; background-color: #fafafa;">Node</span> (<span style="color: #383a42; background-color: #fafafa;">Leaf</span>, <span style="color: #383a42; background-color: #fafafa;">Node</span> (<span style="color: #383a42; background-color: #fafafa;">Leaf</span>,<span style="color: #383a42; background-color: #fafafa;">Leaf</span>,<span style="color: #383a42; background-color: #fafafa;">Leaf</span>), <span style="color: #383a42; background-color: #fafafa;">Leaf</span>))
</pre>
</div>
<p>
s&rsquo;évalue en <code>2</code>.
</p>
</div>
</div>
<div id="outline-container-orgc36ecf6" class="outline-3 spoiler">
<h3 id="orgc36ecf6">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-orgc36ecf6">
<p>
Il faut simplement récupérer la hauteur du plus haut des enfants et y ajouter 1. On fait ceci en composant deux max.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #986801;">ternary_tree</span> = <span style="color: #383a42; background-color: #fafafa;">Leaf</span>
                  | <span style="color: #383a42; background-color: #fafafa;">Node</span> <span style="color: #e45649;">of</span> ternary_tree * ternary_tree * ternary_tree
<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">tree_height</span> <span style="color: #6a1868;">t</span> =
  <span style="color: #e45649;">match</span> t <span style="color: #e45649;">with</span>
  |<span style="color: #383a42; background-color: #fafafa;">Leaf</span> -&gt; <span style="color: #da8548; font-weight: bold;">0</span>
  |<span style="color: #383a42; background-color: #fafafa;">Node</span> (t1, t2, t3) -&gt;
    <span style="color: #da8548; font-weight: bold;">1</span> + (max (tree_height t1)
             (max (tree_height t2) (tree_height t3)))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org50ac458" class="outline-2">
<h2 id="org50ac458">Liste aplatie&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></h2>
<div class="outline-text-2" id="text-org50ac458">
</div>
<div id="outline-container-org0e8ed84" class="outline-3">
<h3 id="org0e8ed84">Énoncé</h3>
<div class="outline-text-3" id="text-org0e8ed84">
<p>
On considère une liste de liste <code>lst</code>. Implémentez une fonction <code>flatten_lst</code> qui transforme cette liste en une liste de tous les éléments.
Par exemple <code>flatten [[1;2];[1;5;6];[1]]</code> s&rsquo;évalue en <code>[1;2;1;5;6;1]</code>.
La complexité sera linéaire en le nombre d&rsquo;éléments du résultat.
</p>
</div>
</div>
<div id="outline-container-org2450974" class="outline-3 spoiler">
<h3 id="org2450974">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org2450974">
<p>
Ici on utilise l&rsquo;opérateur de concaténation <code>@</code> dont la complexité est la taille de la première liste. On a donc bien la complexité attendue.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">flatten</span> <span style="color: #6a1868;">lst</span> =
  <span style="color: #e45649;">match</span> lst <span style="color: #e45649;">with</span>
  |<span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; <span style="color: #383a42; background-color: #fafafa;">[]</span>
  |head_lst<span style="color: #383a42; background-color: #fafafa;">::</span>tail -&gt; head_lst<span style="color: #a52a2a;">@</span>(flatten tail)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd140292" class="outline-2">
<h2 id="orgd140292">Produit scalaire (tableau)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="imp_ratif">impératif</span>&#xa0;<span class="tableau">tableau</span>&#xa0;<span class="r_f_rence">référence</span></span></h2>
<div class="outline-text-2" id="text-orgd140292">
</div>
<div id="outline-container-org7dccffb" class="outline-3">
<h3 id="org7dccffb">Énoncé</h3>
<div class="outline-text-3" id="text-org7dccffb">
<p>
On considère deux vecteurs de même dimension implémentés sous forme de <code>float array</code>.
Implémentez une fonction <code>dot</code> qui réalise le produit scalaire de ces deux vecteurs.
</p>

<p>
Par exemple <code>dot [|1.; 0.|] [|0.; 1.|]</code> s&rsquo;évalue en <code>0.</code> car les deux vecteurs sont orthogonaux.
</p>
</div>
</div>
<div id="outline-container-orgc6885dc" class="outline-3 spoiler">
<h3 id="orgc6885dc">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-orgc6885dc">
<p>
Il suffit de faire une boucle for pour réaliser la somme des produits terme à terme et le stocker dans une <code>ref</code>.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">dot</span> <span style="color: #6a1868;">v1</span> <span style="color: #6a1868;">v2</span> =
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">n1</span> = <span style="color: #986801;">Array.</span>length v1 <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">n2</span> = <span style="color: #986801;">Array.</span>length v2 <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #e45649;">if</span> n1 &lt;&gt; n2 <span style="color: #e45649;">then</span>
    <span style="color: #a626a4;">failwith</span> <span style="color: #50a14f;">"Dimensions incorrectes"</span>
  <span style="color: #e45649;">else</span>
    <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">result</span> = <span style="color: #a626a4;">ref</span> <span style="color: #da8548; font-weight: bold;">0</span>. <span style="color: #000000; font-weight: bold;">in</span>
    <span style="color: #e45649;">for</span> i = <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #e45649;">to</span> n1 -<span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #e45649;">do</span>
      result := <span style="color: #a52a2a;">!</span>result +. v1.(i) *. v2.(i)
    <span style="color: #e45649;">done</span>;
    <span style="color: #a52a2a;">!</span>result
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org71a68fb" class="outline-2">
<h2 id="org71a68fb">Briser les chaînes&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></h2>
<div class="outline-text-2" id="text-org71a68fb">
</div>
<div id="outline-container-orge38e07f" class="outline-3">
<h3 id="orge38e07f">Énoncé</h3>
<div class="outline-text-3" id="text-orge38e07f">
<p>
On considère une chaîne de caractère <code>s</code>. Implémentez une fonction <code>split_on_char</code> qui découpe <code>s</code> en plusieurs sous chaînes délimitées par un caractère passé en argument.
</p>

<p>
Par exemple, <code>split_on_char "this is a sentence " ' '</code> s&rsquo;évalue en <code>["this"; "is"; "a"; "sentence"; ""]</code>, le découpage des sous chaînes délimitées par des espaces. Ici le dernier espace de la chaîne a pour conséquence une chaîne vide à la fin de la liste.
</p>

<p>
Vous pourrez utiliser <code>String.make 1 c</code> qui crée une chaîne de longueur <code>1</code> ne contenant que le caractère <code>c</code>.
</p>
</div>
</div>
<div id="outline-container-orgffa92c0" class="outline-3 spoiler">
<h3 id="orgffa92c0">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-orgffa92c0">
<p>
On procède en parcourant la chaîne récursivement depuis un indice i et en construisant les sous chaînes par accumulation et concaténation des lettres lues tant qu&rsquo;on ne rencontre pas le caractère de séparation.
</p>

<p>
On peut ensuite appeler cette fonction récursive pour <code>i = 0</code> et une chaîne des caractères lus jusque là initialement vide.
</p>

<p>
On aussi aurait pu utiliser <code>String.sub</code> pour obtenir les sous chaînes plutôt que de concatener.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">split_on_char_with_index</span> <span style="color: #6a1868;">previously_read</span> <span style="color: #6a1868;">i</span> <span style="color: #6a1868;">s</span> <span style="color: #6a1868;">sep_char</span> =
  <span style="color: #e45649;">if</span> i = <span style="color: #986801;">String.</span>length s <span style="color: #e45649;">then</span>
    [previously_read]
  <span style="color: #e45649;">else</span> <span style="color: #e45649;">if</span> s.[i] = sep_char <span style="color: #e45649;">then</span>
    previously_read <span style="color: #383a42; background-color: #fafafa;">::</span> split_on_char_with_index <span style="color: #50a14f;">""</span> (i+<span style="color: #da8548; font-weight: bold;">1</span>) s sep_char
  <span style="color: #e45649;">else</span>
     split_on_char_with_index (previously_read<span style="color: #a52a2a;">^</span>(<span style="color: #986801;">String.</span>make <span style="color: #da8548; font-weight: bold;">1</span> s.[i])) (i+<span style="color: #da8548; font-weight: bold;">1</span>) s sep_char

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">split_on_char</span> <span style="color: #6a1868;">s</span> <span style="color: #6a1868;">sep_char</span> =
  split_on_char_with_index <span style="color: #50a14f;">""</span> <span style="color: #da8548; font-weight: bold;">0</span> s sep_char
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org9be9482" class="outline-2">
<h2 id="org9be9482">Découpage régulier de liste&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></h2>
<div class="outline-text-2" id="text-org9be9482">
</div>
<div id="outline-container-org9a9ad19" class="outline-3">
<h3 id="org9a9ad19">Énoncé</h3>
<div class="outline-text-3" id="text-org9a9ad19">
<p>
Implémentez une fonction <code>size_k_split</code> qui découpe une liste en une liste de blocs de termes consécutifs de taille donnée <code>k</code>.
Par exemple, <code>size_k_split 3 [0;1;2;3;4;5;6;7]</code> s&rsquo;évalue en <code>[[0;1;2];[3;4;5][6;7]]</code>, le dernier bloc est éventuellement de taille inférieures à <code>k</code> s&rsquo;il n&rsquo;y a pas assez de termes.
</p>
</div>
</div>
<div id="outline-container-org5b59d69" class="outline-3 spoiler">
<h3 id="org5b59d69">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org5b59d69">
<p>
On commence par implémenter une fonction qui sépare une liste entre ses <code>k</code> premier termes et le reste. Pour ceci, on procède en récupérant <code>k-1</code> éléments sur la fin de la liste, et on ajoute le premier éléments aux <code>k-1</code> éléments obtenus par appel récursif.
</p>

<p>
Puis on applique récursivement cette fonction sur la liste initiale.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">get_first_k_elems</span> <span style="color: #6a1868;">k</span> <span style="color: #6a1868;">lst</span> =
<span style="color: #e45649;">if</span> k = <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #e45649;">then</span>
  (<span style="color: #383a42; background-color: #fafafa;">[]</span>, lst)
<span style="color: #e45649;">else</span> <span style="color: #e45649;">if</span> lst = <span style="color: #383a42; background-color: #fafafa;">[]</span> <span style="color: #e45649;">then</span>
  (<span style="color: #383a42; background-color: #fafafa;">[]</span>, lst)
<span style="color: #e45649;">else</span>
  <span style="color: #000000; font-weight: bold;">let</span> (<span style="color: #6a1868;">elems</span>, <span style="color: #6a1868;">lst_end</span>) = get_first_k_elems (k-<span style="color: #da8548; font-weight: bold;">1</span>) (<span style="color: #986801;">List.</span>tl lst) <span style="color: #000000; font-weight: bold;">in</span>
  ((<span style="color: #986801;">List.</span>hd lst)<span style="color: #383a42; background-color: #fafafa;">::</span>elems, lst_end)

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">size_k_split</span> <span style="color: #6a1868;">k</span> <span style="color: #6a1868;">lst</span> =
  <span style="color: #e45649;">match</span> lst <span style="color: #e45649;">with</span>
  |<span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; <span style="color: #383a42; background-color: #fafafa;">[]</span>
  |lst -&gt; <span style="color: #000000; font-weight: bold;">let</span> (<span style="color: #6a1868;">k_first</span>, <span style="color: #6a1868;">end_lst</span>) = get_first_k_elems k lst <span style="color: #000000; font-weight: bold;">in</span>
          k_first<span style="color: #383a42; background-color: #fafafa;">::</span>(size_k_split k end_lst)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org14caf46" class="outline-2">
<h2 id="org14caf46">Tri par insertion&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></h2>
<div class="outline-text-2" id="text-org14caf46">
</div>
<div id="outline-container-org0970b28" class="outline-3">
<h3 id="org0970b28">Énoncé</h3>
<div class="outline-text-3" id="text-org0970b28">
<p>
Implémentez une fonction <code>insertion_sort</code> qui réalise le tri par insertion d&rsquo;une liste.
</p>

<p>
Par exemple <code>insertion_sort ['a'; 'c'; 'b'; 'z'; 'a']</code> s&rsquo;évalue en <code>['a'; 'a'; 'b'; 'c'; 'z']</code>.
Vous n&rsquo;utiliserez par de boucle.
</p>
</div>
</div>
<div id="outline-container-org24c3a46" class="outline-3 spoiler">
<h3 id="org24c3a46">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org24c3a46">
<p>
On commence par implémenter une fonction qui insère un élément <code>e</code> à la bonne place dans une liste déjà triée. Puis on trie la fin de la liste récursivement, et on insère la tête à la bonne place dans la fin triée de la liste.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">insert_at_correct_position</span> <span style="color: #6a1868;">e</span> <span style="color: #6a1868;">lst</span> =
  <span style="color: #e45649;">match</span> lst <span style="color: #e45649;">with</span>
  |<span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; [e]
  |head<span style="color: #383a42; background-color: #fafafa;">::</span>tail <span style="color: #e45649;">when</span> e &lt;= head -&gt; e<span style="color: #383a42; background-color: #fafafa;">::</span>head<span style="color: #383a42; background-color: #fafafa;">::</span>tail
  |head<span style="color: #383a42; background-color: #fafafa;">::</span>tail <span style="color: #9ca0a4;">(*</span><span style="color: #9ca0a4;">e &gt; head</span><span style="color: #9ca0a4;">*)</span> -&gt; head<span style="color: #383a42; background-color: #fafafa;">::</span>(insert_at_correct_position e tail)

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">insertion_sort</span> <span style="color: #6a1868;">lst</span> =
  <span style="color: #e45649;">match</span> lst <span style="color: #e45649;">with</span>
  |<span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; <span style="color: #383a42; background-color: #fafafa;">[]</span>
  |head<span style="color: #383a42; background-color: #fafafa;">::</span>tail -&gt; insert_at_correct_position head (insertion_sort tail)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd08fad3" class="outline-2">
<h2 id="orgd08fad3">Filtrage d&rsquo;une liste&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span>&#xa0;<span class="func">func</span></span></h2>
<div class="outline-text-2" id="text-orgd08fad3">
</div>
<div id="outline-container-org3c99547" class="outline-3">
<h3 id="org3c99547">Énoncé</h3>
<div class="outline-text-3" id="text-org3c99547">
<p>
Implémenter une fonction <code>list_filter</code> prenant en entrée un prédicat <code>p</code> et une liste <code>lst</code> et filtrant en une liste des éléments de <code>lst</code> vérifiant <code>p</code>.
Par exemple <code>list_filter (fun x -&gt; x &gt; 5) [1;7;3;8]</code> s&rsquo;évalue en <code>[7;8]</code>.
</p>

<p>
Cette fonction réplique le comportement de la fonction <code>List.filter</code> du module <code>List</code> que vous n&rsquo;utilisez <b>pas</b> dans cet exercice.
</p>
</div>
</div>
<div id="outline-container-org57b2d56" class="outline-3 spoiler">
<h3 id="org57b2d56">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org57b2d56">
<p>
Il suffit de parcourir la liste et de ne garder que les éléments qui vérifient <code>p</code>.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">list_filter</span> <span style="color: #6a1868;">p</span> <span style="color: #6a1868;">lst</span> =
   <span style="color: #e45649;">match</span> lst <span style="color: #e45649;">with</span>
   |<span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; <span style="color: #383a42; background-color: #fafafa;">[]</span>
   |head<span style="color: #383a42; background-color: #fafafa;">::</span>tail <span style="color: #e45649;">when</span> p head -&gt; head<span style="color: #383a42; background-color: #fafafa;">::</span>list_filter p tail
   |head<span style="color: #383a42; background-color: #fafafa;">::</span>tail <span style="color: #9ca0a4;">(* </span><span style="color: #9ca0a4;">not p head</span><span style="color: #9ca0a4;"> *)</span>-&gt; list_filter p tail
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org910e65a" class="outline-2">
<h2 id="org910e65a">Inversion de liste (impératif)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="imp_ratif">impératif</span>&#xa0;<span class="r_f_rence">référence</span></span></h2>
<div class="outline-text-2" id="text-org910e65a">
</div>
<div id="outline-container-org4e96203" class="outline-3">
<h3 id="org4e96203">Énoncé</h3>
<div class="outline-text-3" id="text-org4e96203">
<p>
Implémenter une fonction <code>list_rev</code> dont l&rsquo;appel sur une liste s&rsquo;évalue en cette liste dont l&rsquo;ordre des éléments a été changé.
Par exemple <code>list_rev [0;1;2;3]</code> s&rsquo;évalue en <code>[3;2;1;0]</code>.
Vous n&rsquo;utiliserez pas de fonction récursive.
</p>
</div>
</div>
<div id="outline-container-orgaedf079" class="outline-3 spoiler">
<h3 id="orgaedf079">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-orgaedf079">
<p>
Le principe est de travailler avec une référence vers liste contenant ce qui a déjà été inversé (le début de la liste déjà traité, ici <code>already_done_lst</code>) et une contenant ce qu&rsquo;il reste à faire (ici <code>todo</code>). Ensuite, on place en tête de cette liste le premier élément de la liste à traiter, puis on le retire de la liste à traiter.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">list_rev</span> <span style="color: #6a1868;">lst</span> =
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">already_done</span> = <span style="color: #a626a4;">ref</span> <span style="color: #383a42; background-color: #fafafa;">[]</span> <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">todo</span> = <span style="color: #a626a4;">ref</span> lst <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #e45649;">while</span> <span style="color: #a52a2a;">!</span>todo &lt;&gt; <span style="color: #383a42; background-color: #fafafa;">[]</span> <span style="color: #e45649;">do</span>
    already_done := (<span style="color: #986801;">List.</span>hd (<span style="color: #a52a2a;">!</span>todo)) <span style="color: #383a42; background-color: #fafafa;">::</span> <span style="color: #a52a2a;">!</span>already_done;
    todo := (<span style="color: #986801;">List.</span>tl (<span style="color: #a52a2a;">!</span>todo))
  <span style="color: #e45649;">done</span>;
  <span style="color: #a52a2a;">!</span>already_done;
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org205d3b9" class="outline-2">
<h2 id="org205d3b9">Évaluation d&rsquo;un polynôme en un point (liste)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></h2>
<div class="outline-text-2" id="text-org205d3b9">
</div>
<div id="outline-container-org356d257" class="outline-3">
<h3 id="org356d257">Énoncé</h3>
<div class="outline-text-3" id="text-org356d257">
<p>
On considère un polynôme à coefficients <code>float</code> représenté par la listes de ses coefficients. Le terme de rang <code>i</code> contient le coefficient de degré <code>i</code>.
Implémentez une fonction <code>eval_at_list</code> qui prend ce polynôme et un flottant et évalue ce polynôme en ce flottant.
</p>

<p>
La complexité sera linéaire en le degré du polynôme.
</p>

<p>
Par exemple <code>eval_at_list [5.;6.] 1.</code> s&rsquo;évalue en <code>11.0</code>.
</p>
</div>
</div>
<div id="outline-container-org6a216ff" class="outline-3 spoiler">
<h3 id="org6a216ff">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org6a216ff">
<p>
Pour éviter les coûts liés aux calculs des puissances itérées, utilise la relation suivante (dite de Horner) \(\sum\limits_{i=0}^{d-1}a_i × x^i = a_0 + x × \left(\sum\limits_{i=0}^{d-2} a_{i-1}x^i\right)\).
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">eval_at_list</span> <span style="color: #6a1868;">p</span> <span style="color: #6a1868;">x</span> =
  <span style="color: #e45649;">match</span> p <span style="color: #e45649;">with</span>
  |<span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; <span style="color: #da8548; font-weight: bold;">0</span>.
  |head<span style="color: #383a42; background-color: #fafafa;">::</span>tail -&gt; head +. (x *. (eval_at_list tail x))
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org82094a0" class="outline-2">
<h2 id="org82094a0">Fusion alternée&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></h2>
<div class="outline-text-2" id="text-org82094a0">
</div>
<div id="outline-container-org2bd91f0" class="outline-3">
<h3 id="org2bd91f0">Énoncé</h3>
<div class="outline-text-3" id="text-org2bd91f0">
<p>
Implémentez une fonction <code>alternate_merge</code> qui fusionne les éléments de deux listes en une seule en alternant un élément d&rsquo;une liste puis un de la suivante tant que c&rsquo;est possible.
</p>

<p>
Par exemple <code>alternate_merge [0;2;4;6] [1;3]</code> s&rsquo;évalue en <code>[0;1;2;3;4;6]</code>. La première liste étant plus longue, on termine avec uniquement des éléments de celle ci (4 et 6).
</p>
</div>
</div>
<div id="outline-container-org19e4ec7" class="outline-3 spoiler">
<h3 id="org19e4ec7">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org19e4ec7">
<p>
On parcourt simultanément les deux liste tant qu&rsquo;il reste des éléments, et on place en premier la tête de la première liste, suivie par la tête de la deuxième puis la fin de la fusion via un appel récursif.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">alternate_merge</span> <span style="color: #6a1868;">lst1</span> <span style="color: #6a1868;">lst2</span> =
  <span style="color: #e45649;">match</span> lst1,lst2 <span style="color: #e45649;">with</span>
  |<span style="color: #383a42; background-color: #fafafa;">[]</span>, lst | lst, <span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; lst
  |h1<span style="color: #383a42; background-color: #fafafa;">::</span>t1, h2<span style="color: #383a42; background-color: #fafafa;">::</span>t2 -&gt; h1<span style="color: #383a42; background-color: #fafafa;">::</span>h2<span style="color: #383a42; background-color: #fafafa;">::</span>(alternate_merge t1 t2)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orga2babd6" class="outline-2">
<h2 id="orga2babd6">Deuxième max d&rsquo;une liste&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span>&#xa0;<span class="option">option</span></span></h2>
<div class="outline-text-2" id="text-orga2babd6">
</div>
<div id="outline-container-orgc39564c" class="outline-3">
<h3 id="orgc39564c">Énoncé</h3>
<div class="outline-text-3" id="text-orgc39564c">
<p>
On considère une liste <code>lst</code> dont on cherche le deuxième plus grand élément.
Implémentez une fonction <code>second_max</code> qui renvoie, s&rsquo;il existe cet élément. Vous utiliserez un type option pour gérer les cas où cet élément n&rsquo;existe pas.
</p>

<p>
Par exemple, <code>second_max [1; 1; 1]</code> s&rsquo;évalue en <code>None</code> et <code>second_max [2; 23; 6]</code> s&rsquo;évalue en <code>Some 6</code>.
</p>
</div>
</div>
<div id="outline-container-orgff442f5" class="outline-3 spoiler">
<h3 id="orgff442f5">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-orgff442f5">
<p>
On utilise une fonction auxiliaire qui prends en argument les deux plus grands éléments rencontrés jusque là, éventuellement égaux. Quand un nouvel élément plus grand est trouvé, l&rsquo;ancien max devient le second max.
Ensuite on appelle cette fonction avec pour valeur initial du plus grand élément la tête de la liste dont on cherche le second max.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">second_max_with_acc</span> <span style="color: #6a1868;">lst</span> <span style="color: #6a1868;">current_max</span> <span style="color: #6a1868;">second_max</span> =
  <span style="color: #e45649;">match</span> lst <span style="color: #e45649;">with</span>
    |<span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; <span style="color: #e45649;">if</span> second_max = current_max <span style="color: #e45649;">then</span>
             <span style="color: #383a42; background-color: #fafafa;">None</span>
           <span style="color: #e45649;">else</span>
             <span style="color: #383a42; background-color: #fafafa;">Some</span> second_max
    |head<span style="color: #383a42; background-color: #fafafa;">::</span>tail <span style="color: #e45649;">when</span> head &gt; current_max -&gt;
      second_max_with_acc tail head current_max
    |head<span style="color: #383a42; background-color: #fafafa;">::</span>tail <span style="color: #e45649;">when</span> head &gt; second_max -&gt;
      second_max_with_acc tail current_max head
    |head<span style="color: #383a42; background-color: #fafafa;">::</span>tail -&gt;
      second_max_with_acc tail current_max second_max

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">second_max</span> <span style="color: #6a1868;">lst</span> =
  <span style="color: #e45649;">match</span> lst <span style="color: #e45649;">with</span>
    |<span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; <span style="color: #383a42; background-color: #fafafa;">None</span>
    |head<span style="color: #383a42; background-color: #fafafa;">::</span>tail -&gt;
      second_max_with_acc tail head head

</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org3421a6d" class="outline-2">
<h2 id="org3421a6d">PGCD d&rsquo;une liste&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></h2>
<div class="outline-text-2" id="text-org3421a6d">
</div>
<div id="outline-container-org6a022f0" class="outline-3">
<h3 id="org6a022f0">Énoncé</h3>
<div class="outline-text-3" id="text-org6a022f0">
<p>
Implémentez une fonction <code>list_gcd</code> qui calcule le PGCD de tous les éléments d&rsquo;une liste.
</p>

<p>
Par exemple <code>list_gcd [12; 18; 27]</code> s&rsquo;évalue en <code>3</code>.
</p>
</div>
</div>
<div id="outline-container-org747c20f" class="outline-3 spoiler">
<h3 id="org747c20f">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org747c20f">
<p>
On commence par implémenter une fonction qui calcule le PGCD de deux nombres. Pour cela on procède de manière récursive via la relation <code>gcd a b = gcd b (a mod b)</code> et <code>gcd a 0 = a</code> (algorithme d&rsquo;Euclide).
</p>

<p>
Ensuite, on peut calculer récursivement le PGCD de la fin de la liste, puis obtenir le PGCD de la liste en faisant le PGCD de la fin et de la tête.
Dans le cas d&rsquo;une liste vide, <code>0</code> est un bon diviseur, cas il est neutre pour l&rsquo;opération de PGCD.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">gcd</span> <span style="color: #6a1868;">a</span> <span style="color: #6a1868;">b</span> =
  <span style="color: #e45649;">if</span> b = <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #e45649;">then</span>
    a
  <span style="color: #e45649;">else</span>
    gcd b (a <span style="color: #a52a2a;">mod</span> b)

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">list_gcd</span> <span style="color: #6a1868;">lst</span> =
  <span style="color: #e45649;">match</span> lst <span style="color: #e45649;">with</span>
  |<span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; <span style="color: #da8548; font-weight: bold;">0</span>
  |head<span style="color: #383a42; background-color: #fafafa;">::</span>tail -&gt; gcd head (list_gcd tail)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org0533045" class="outline-2">
<h2 id="org0533045">Simplification de fraction&#xa0;&#xa0;&#xa0;<span class="tag"><span class="enregistrement">enregistrement</span></span></h2>
<div class="outline-text-2" id="text-org0533045">
</div>
<div id="outline-container-orga01a530" class="outline-3">
<h3 id="orga01a530">Énoncé</h3>
<div class="outline-text-3" id="text-orga01a530">
<p>
On s&rsquo;intéresse à des fractions implémentées à l&rsquo;aide d&rsquo;un enregistrement dont les champs sont <code>numerator</code> et <code>denominator</code>.
Implémentez le type <code>fraction</code> correspondant, puis implémentez une fonction <code>make_fraction a b</code> qui s&rsquo;évalue en la fraction \(\frac{a}{b}\) et implémentez une fonction <code>simplify  : fraction -&gt; unit</code> qui modifie <b>en place</b> la fraction de manière à la rendre irréductible.
</p>

<p>
Par exemple, si on pose <code>let f = make_fraction 6 9</code> puis qu&rsquo;on évalue <code>simplify f</code>, on aura une fraction dont le numérateur et le dénominateur sont 2 et 3.
</p>
</div>
</div>
<div id="outline-container-orga71c682" class="outline-3 spoiler">
<h3 id="orga71c682">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-orga71c682">
<p>
Après avoir implémenté le type (on n&rsquo;oublie pas le type de chaque champ), on implémente une fonction de calcul du PGCD pour simplifier la fraction via l&rsquo;algorithme d&rsquo;Euclide.
</p>

<p>
Puis on divise le numérateur et le dénominateur par le PGCD des deux pour simplifier.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #986801;">fraction</span> = {<span style="color: #e45649;">mutable</span> numerator : int;
                 <span style="color: #e45649;">mutable</span> denominator : int}

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">make_fraction</span> <span style="color: #6a1868;">a</span> <span style="color: #6a1868;">b</span> =
  {numerator = a; denominator = b}

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">gcd</span> <span style="color: #6a1868;">a</span> <span style="color: #6a1868;">b</span> =
  <span style="color: #e45649;">if</span> b = <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #e45649;">then</span>
    a
  <span style="color: #e45649;">else</span>
    gcd b (a <span style="color: #a52a2a;">mod</span> b)

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">simplify</span> <span style="color: #6a1868;">f</span> =
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">gcd_num_denom</span> = gcd f.numerator f.denominator <span style="color: #000000; font-weight: bold;">in</span>
  f.numerator &lt;- f.numerator / gcd_num_denom;
  f.denominator &lt;- f.denominator / gcd_num_denom
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org334b35c" class="outline-2">
<h2 id="org334b35c">Itérer sur une liste&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span>&#xa0;<span class="func">func</span></span></h2>
<div class="outline-text-2" id="text-org334b35c">
</div>
<div id="outline-container-org30cbf51" class="outline-3">
<h3 id="org30cbf51">Énoncé</h3>
<div class="outline-text-3" id="text-org30cbf51">
<p>
Implémenter une fonction <code>list_iter</code> prenant en entrée une fonction à effet de bord <code>f</code> et une liste <code>lst</code> et appelant la fonction <code>f</code> sur chaque élément de <code>lst</code> dans l&rsquo;ordre.
Par exemple <code>list_map (fun x -&gt; print_int x) [1;2;3]</code> affiche <code>123</code>.
</p>

<p>
Cette fonction réplique le comportement de la fonction <code>List.iter</code> du module <code>List</code> que vous n&rsquo;utilisez <b>pas</b> dans cet exercice.
</p>
</div>
</div>
<div id="outline-container-org04abc8a" class="outline-3 spoiler">
<h3 id="org04abc8a">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org04abc8a">
<p>
Il suffit de parcourir récursivement la liste et d&rsquo;appliquer <code>f</code> à tous les éléments rencontrés.
Attention, il faut gérer le cas de la liste vide, une fonction à effet de bord a une image de type <code>unit</code>, ce qui signifie que pour la liste vide, on peut &laquo;&nbsp;ne rien faire&nbsp;&raquo; en s&rsquo;évaluant en <code>()</code>, la seule valeur de type <code>unit</code>.
</p>

<p>
On prend soin d&rsquo;appeler <code>f</code> sur la tête <b>avant</b> de réaliser l&rsquo;appel récursif.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">list_iter</span> <span style="color: #6a1868;">f</span> <span style="color: #6a1868;">lst</span> =
  <span style="color: #e45649;">match</span> lst <span style="color: #e45649;">with</span>
  |<span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; ()
  |head<span style="color: #383a42; background-color: #fafafa;">::</span>tail -&gt; <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">_</span> = f head <span style="color: #000000; font-weight: bold;">in</span> (list_iter f tail)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org64e0643" class="outline-2">
<h2 id="org64e0643">Recherche dichotomique&#xa0;&#xa0;&#xa0;<span class="tag"><span class="imp_ratif">impératif</span>&#xa0;<span class="tableau">tableau</span>&#xa0;<span class="option">option</span>&#xa0;<span class="r_f_rence">référence</span></span></h2>
<div class="outline-text-2" id="text-org64e0643">
</div>
<div id="outline-container-org5b0d5c4" class="outline-3">
<h3 id="org5b0d5c4">Énoncé</h3>
<div class="outline-text-3" id="text-org5b0d5c4">
<p>
On considère un tableau trié d&rsquo;éléments <code>a</code> et un élément de même type <code>e</code>. Implémentez une fonction <code>dicho_search</code> qui recherche l&rsquo;élément <code>e</code> dans <code>a</code> et renvoie son indice s&rsquo;il existe. On utilisera un type option pour gérer le cas où cet indice n&rsquo;existe pas.
</p>

<p>
Par exemple, <code>dicho_search 7 [|1;2;3;4;5;6|]</code> s&rsquo;évaluera en <code>None</code>.
</p>
</div>
</div>
<div id="outline-container-org856f629" class="outline-3 spoiler">
<h3 id="org856f629">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org856f629">
<p>
Pour réaliser la recherche dichotomique, on pose deux références <code>be</code> et <code>en</code> correspondant respectivement à l&rsquo;indice de la première case de la zone de recherche et à l&rsquo;indice de la première case juste après la zone de recherche.
</p>

<p>
Initialement, on a <code>be = 0</code> et <code>en = Array.length a</code>.
</p>

<p>
On applique ensuite l&rsquo;algorithme classique de recherche dichotomique.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">dicho_search</span> <span style="color: #6a1868;">e</span> <span style="color: #6a1868;">a</span> =
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">be</span> = <span style="color: #a626a4;">ref</span> <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">en</span> = <span style="color: #a626a4;">ref</span> (<span style="color: #986801;">Array.</span>length a) <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">result</span> = <span style="color: #a626a4;">ref</span> <span style="color: #383a42; background-color: #fafafa;">None</span> <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #e45649;">while</span> <span style="color: #a52a2a;">!</span>en &gt; <span style="color: #a52a2a;">!</span>be <span style="color: #a52a2a;">&amp;&amp;</span> <span style="color: #a52a2a;">!</span>result = <span style="color: #383a42; background-color: #fafafa;">None</span> <span style="color: #e45649;">do</span>
    <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">middle_index</span> = (<span style="color: #a52a2a;">!</span>en + <span style="color: #a52a2a;">!</span>be)/<span style="color: #da8548; font-weight: bold;">2</span> <span style="color: #000000; font-weight: bold;">in</span>
    <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">middle_value</span> = a.(middle_index) <span style="color: #000000; font-weight: bold;">in</span>
    <span style="color: #e45649;">if</span> middle_value = e <span style="color: #e45649;">then</span>
      (
        result := <span style="color: #383a42; background-color: #fafafa;">Some</span> middle_index
      )
    <span style="color: #e45649;">else</span> <span style="color: #e45649;">if</span> middle_value &lt; e <span style="color: #e45649;">then</span>
      be := (middle_index + <span style="color: #da8548; font-weight: bold;">1</span>) <span style="color: #9ca0a4;">(* </span><span style="color: #9ca0a4;">le +1 est important</span><span style="color: #9ca0a4;"> *)</span>
    <span style="color: #e45649;">else</span> <span style="color: #9ca0a4;">(*</span><span style="color: #9ca0a4;">middle_value &lt; e</span><span style="color: #9ca0a4;">*)</span>
      en := middle_index
  <span style="color: #e45649;">done</span>;
  <span style="color: #a52a2a;">!</span>result
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org7c93433" class="outline-2">
<h2 id="org7c93433">k-accessibles&#xa0;&#xa0;&#xa0;<span class="tag"><span class="imp_ratif">impératif</span>&#xa0;<span class="tableau">tableau</span>&#xa0;<span class="liste">liste</span>&#xa0;<span class="rec">rec</span>&#xa0;<span class="r_f_rence">référence</span></span></h2>
<div class="outline-text-2" id="text-org7c93433">
</div>
<div id="outline-container-org281d7d0" class="outline-3">
<h3 id="org281d7d0">Énoncé</h3>
<div class="outline-text-3" id="text-org281d7d0">
<p>
On considère un graphe représenté par listes d&rsquo;adjacences implémentées par le type <code>(int list) array</code>.
Implémentez une fonction <code>k_reachable</code> qui détermine la liste des sommets accessibles en exactement <code>k</code> étape à partir d&rsquo;une liste de sommets initiaux.
</p>

<p>
Par exemple pour le graphe <code>let g = [|[2;3];[2];[4];[4];[1]|]</code>, <code>k_reachable g 2 [0;1]</code> s&rsquo;évalue en <code>[4]</code>, qui est la liste des sommets accessibles à partir des sommets <code>0</code> et <code>1</code> en exactement <code>2</code> étapes dans <code>g</code>.
</p>
</div>
</div>
<div id="outline-container-org122e41b" class="outline-3 spoiler">
<h3 id="org122e41b">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org122e41b">
<p>
Pour calculer la liste demandée, on va procéder en calculant la liste des sommets accessible en exactement une étape et répéter ceci <code>k</code> fois à partir de la liste obtenue à l&rsquo;étape précédente. Afin d&rsquo;éviter des calculs inutiles, on va commencer par implémenter une fonction d&rsquo;insertion dans doublons dans une liste.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">insert_no_duplicates</span> <span style="color: #6a1868;">x</span> <span style="color: #6a1868;">lst</span> =
  <span style="color: #e45649;">match</span> lst <span style="color: #e45649;">with</span>
  |<span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; [x]
  |head<span style="color: #383a42; background-color: #fafafa;">::</span>tail <span style="color: #e45649;">when</span> head = x -&gt; lst
  |head<span style="color: #383a42; background-color: #fafafa;">::</span>tail <span style="color: #9ca0a4;">(* </span><span style="color: #9ca0a4;">head &lt;&gt;x</span><span style="color: #9ca0a4;"> *)</span> -&gt; head<span style="color: #383a42; background-color: #fafafa;">::</span>(insert_no_duplicates x tail)

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">k_reachable</span> <span style="color: #6a1868;">g</span> <span style="color: #6a1868;">k</span> <span style="color: #6a1868;">vertex_lst</span> =
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">current_vertices</span> = <span style="color: #a626a4;">ref</span> vertex_lst <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #e45649;">for</span> i = <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #e45649;">to</span> k-<span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #e45649;">do</span>
    <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">next_vertices</span> = <span style="color: #a626a4;">ref</span> <span style="color: #383a42; background-color: #fafafa;">[]</span> <span style="color: #000000; font-weight: bold;">in</span>
    <span style="color: #e45649;">while</span> <span style="color: #a52a2a;">!</span>current_vertices &lt;&gt; <span style="color: #383a42; background-color: #fafafa;">[]</span> <span style="color: #e45649;">do</span>
      <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">v</span> = <span style="color: #986801;">List.</span>hd <span style="color: #a52a2a;">!</span>current_vertices <span style="color: #000000; font-weight: bold;">in</span>
      <span style="color: #986801;">List.</span>iter
        (<span style="color: #e45649;">fun</span> <span style="color: #6a1868;">x</span> -&gt;
          next_vertices := insert_no_duplicates x <span style="color: #a52a2a;">!</span>next_vertices)
        g.(v);
        current_vertices := <span style="color: #986801;">List.</span>tl <span style="color: #a52a2a;">!</span>current_vertices
    <span style="color: #e45649;">done</span>;
    current_vertices := <span style="color: #a52a2a;">!</span>next_vertices
  <span style="color: #e45649;">done</span>;
  <span style="color: #a52a2a;">!</span>current_vertices
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org946e018" class="outline-2">
<h2 id="org946e018">Recherche de mot dans un texte&#xa0;&#xa0;&#xa0;<span class="tag"><span class="imp_ratif">impératif</span>&#xa0;<span class="r_f_rence">référence</span>&#xa0;<span class="option">option</span></span></h2>
<div class="outline-text-2" id="text-org946e018">
</div>
<div id="outline-container-orgf643815" class="outline-3">
<h3 id="orgf643815">Énoncé</h3>
<div class="outline-text-3" id="text-orgf643815">
<p>
Implémentez une fonction <code>ctrl_f</code> qui recherche un mot <code>w</code> dans un texte <code>t</code> et renvoie son indice s&rsquo;il est dans le texte. Vous utiliserez un type option pour gérer le cas où le mot n&rsquo;est pas dans le texte.
</p>

<p>
Par exemple <code>ctrl_f "test" "conteste"</code> s&rsquo;évalue en <code>Some 3</code>.
</p>
</div>
</div>
<div id="outline-container-org4618b18" class="outline-3 spoiler">
<h3 id="org4618b18">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org4618b18">
<p>
Pour chaque position de départ possible dans le texte, on parcourt toutes les lettres du mot recherché pour voir si on trouve un occurrence.
</p>

<p>
Attention à de pas dépasser les bornes des tableaux.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">ctrl_f</span> <span style="color: #6a1868;">w</span> <span style="color: #6a1868;">t</span> =
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">result</span> = <span style="color: #a626a4;">ref</span> <span style="color: #383a42; background-color: #fafafa;">None</span> <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #e45649;">for</span> i = <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #e45649;">to</span> <span style="color: #986801;">String.</span>length t <span style="color: #e45649;">do</span>
    <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">j</span> = <span style="color: #a626a4;">ref</span>  <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #000000; font-weight: bold;">in</span>
    <span style="color: #e45649;">while</span> <span style="color: #a52a2a;">!</span>j + i &lt; <span style="color: #986801;">String.</span>length t <span style="color: #a52a2a;">&amp;&amp;</span> <span style="color: #a52a2a;">!</span>j &lt; <span style="color: #986801;">String.</span>length w <span style="color: #e45649;">do</span>
      <span style="color: #e45649;">if</span> w.[<span style="color: #a52a2a;">!</span>j] = t.[i+ <span style="color: #a52a2a;">!</span>j] <span style="color: #e45649;">then</span>
        j := <span style="color: #a52a2a;">!</span>j +<span style="color: #da8548; font-weight: bold;">1</span>
      <span style="color: #e45649;">else</span>
        j :=  (<span style="color: #986801;">String.</span>length w) + <span style="color: #da8548; font-weight: bold;">1</span>
    <span style="color: #e45649;">done</span>;
    <span style="color: #e45649;">if</span> <span style="color: #a52a2a;">!</span>j = <span style="color: #986801;">String.</span>length w <span style="color: #e45649;">then</span>
      <span style="color: #9ca0a4;">(*</span><span style="color: #9ca0a4;">pas de passage dans le else, on a trouv&#233; une occurrence</span><span style="color: #9ca0a4;">*)</span>
      result := <span style="color: #383a42; background-color: #fafafa;">Some</span> i
    <span style="color: #e45649;">done</span>;
  <span style="color: #a52a2a;">!</span>result
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org75b2ba8" class="outline-2">
<h2 id="org75b2ba8">Recherche dans un Arbre Binaire de recherche&#xa0;&#xa0;&#xa0;<span class="tag"><span class="type_rec">type_rec</span>&#xa0;<span class="option">option</span></span></h2>
<div class="outline-text-2" id="text-org75b2ba8">
</div>
<div id="outline-container-orga7dfe18" class="outline-3">
<h3 id="orga7dfe18">Énoncé</h3>
<div class="outline-text-3" id="text-orga7dfe18">
<p>
On s&rsquo;intéresse à une implémentation des arbres binaires de recherche à l&rsquo;aide d&rsquo;un type récursif dont le constructeur pour un arbre vide est nommé <code>Empty</code> et le constructeur pour un noeud est nommé <code>Node</code> et prend un triplet (fils gauche, (couple clé, valeur), fils droit) en paramètre.
Implémentez le type récursif <code>abr</code> correspondant, les clés seront des <code>string</code> et les valeurs de <code>int</code>.
</p>

<p>
Implémentez une fonction <code>abr_search</code> qui recherche  une valeur <code>v</code> associée à une clé <code>k</code> dans un ABR <code>t</code>. L&rsquo;absence de l&rsquo;élément sera gérée à l&rsquo;aide d&rsquo;un type option.
</p>

<p>
Par exemple =
</p>
<div class="org-src-container">
<pre class="src src-ocaml">abr_search <span style="color: #50a14f;">"key"</span> (<span style="color: #383a42; background-color: #fafafa;">Node</span> (
                      <span style="color: #383a42; background-color: #fafafa;">Node</span> (<span style="color: #383a42; background-color: #fafafa;">Empty</span>, (<span style="color: #50a14f;">"hey"</span>, <span style="color: #da8548; font-weight: bold;">0</span>), <span style="color: #383a42; background-color: #fafafa;">Empty</span>),
                      (<span style="color: #50a14f;">"jey"</span>,<span style="color: #da8548; font-weight: bold;">1</span>),
                      (<span style="color: #383a42; background-color: #fafafa;">Node</span> (<span style="color: #383a42; background-color: #fafafa;">Empty</span>, (<span style="color: #50a14f;">"key"</span>,<span style="color: #da8548; font-weight: bold;">2</span>),<span style="color: #383a42; background-color: #fafafa;">Empty</span>))
                    )
                 )
</pre>
</div>
<p>
s&rsquo;évaluera en <code>2</code> et
</p>
<div class="org-src-container">
<pre class="src src-ocaml">abr_search <span style="color: #50a14f;">"ley"</span> (<span style="color: #383a42; background-color: #fafafa;">Node</span> (
                      <span style="color: #383a42; background-color: #fafafa;">Node</span> (<span style="color: #383a42; background-color: #fafafa;">Empty</span>, (<span style="color: #50a14f;">"hey"</span>, <span style="color: #da8548; font-weight: bold;">0</span>), <span style="color: #383a42; background-color: #fafafa;">Empty</span>),
                      (<span style="color: #50a14f;">"jey"</span>,<span style="color: #da8548; font-weight: bold;">1</span>),
                      (<span style="color: #383a42; background-color: #fafafa;">Node</span> (<span style="color: #383a42; background-color: #fafafa;">Empty</span>, (<span style="color: #50a14f;">"key"</span>,<span style="color: #da8548; font-weight: bold;">2</span>),<span style="color: #383a42; background-color: #fafafa;">Empty</span>))
                    )
                )
</pre>
</div>
<p>
s&rsquo;évaluera en <code>None</code>.
</p>
</div>
</div>
<div id="outline-container-orgd9b6263" class="outline-3 spoiler">
<h3 id="orgd9b6263">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-orgd9b6263">
<p>
On commence par implémenter le type de demandé.
</p>

<p>
Ensuite, il s&rsquo;agit de faire un parcours récursif de l&rsquo;arbre en descendant à gauche ou à droite selon la manière dont la valeur du noeud courant se compare à l&rsquo;élément recherché.
</p>

<p>
En arrivant sur un arbre vide, on ne peut plus continuer, on sait qu&rsquo;on ne pourra pas le trouver.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #986801;">abr</span> = <span style="color: #383a42; background-color: #fafafa;">Empty</span> | <span style="color: #383a42; background-color: #fafafa;">Node</span> <span style="color: #e45649;">of</span> abr * (string * int) * abr

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">abr_search</span> <span style="color: #6a1868;">e</span> <span style="color: #6a1868;">t</span> =
  <span style="color: #e45649;">match</span> t <span style="color: #e45649;">with</span>
  |<span style="color: #383a42; background-color: #fafafa;">Empty</span> -&gt; <span style="color: #383a42; background-color: #fafafa;">None</span>
  |<span style="color: #383a42; background-color: #fafafa;">Node</span> (l, (k,v), r) <span style="color: #e45649;">when</span> k = e -&gt; <span style="color: #383a42; background-color: #fafafa;">Some</span> v
  |<span style="color: #383a42; background-color: #fafafa;">Node</span> (l, (k,v), r) <span style="color: #e45649;">when</span> k &gt; e -&gt; abr_search e l
  |<span style="color: #383a42; background-color: #fafafa;">Node</span> (l, (k,v), r) <span style="color: #9ca0a4;">(* </span><span style="color: #9ca0a4;">k &lt; e</span><span style="color: #9ca0a4;"> *)</span> -&gt; abr_search e r
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org5179bce" class="outline-2">
<h2 id="org5179bce">Produit scalaire (liste)&#xa0;&#xa0;&#xa0;<span class="tag"><span class="liste">liste</span>&#xa0;<span class="rec">rec</span></span></h2>
<div class="outline-text-2" id="text-org5179bce">
</div>
<div id="outline-container-org65ec5af" class="outline-3">
<h3 id="org65ec5af">Énoncé</h3>
<div class="outline-text-3" id="text-org65ec5af">
<p>
On considère deux vecteurs de même dimension implémentés sous forme de <code>float list</code>.
Implémentez une fonction <code>dot</code> qui réalise le produit scalaire de ces deux vecteurs.
</p>

<p>
Par exemple <code>dot [1.; 0.] [0.; 1.]</code> s&rsquo;évalue en <code>0.</code> car les deux vecteurs sont orthogonaux.
</p>
</div>
</div>
<div id="outline-container-org7da7d2c" class="outline-3 spoiler">
<h3 id="org7da7d2c">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org7da7d2c">
<p>
On parcourt les liste en simultané et on somme les produits terme à terme au résultat obtenu par l&rsquo;appel récursif.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">dot</span> <span style="color: #6a1868;">v1</span> <span style="color: #6a1868;">v2</span> =
<span style="color: #e45649;">match</span> v1, v2 <span style="color: #e45649;">with</span>
|<span style="color: #383a42; background-color: #fafafa;">[]</span>, <span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; <span style="color: #da8548; font-weight: bold;">0</span>.
|_,<span style="color: #383a42; background-color: #fafafa;">[]</span> | <span style="color: #383a42; background-color: #fafafa;">[]</span>,_ -&gt; <span style="color: #a626a4;">failwith</span> <span style="color: #50a14f;">"Dimensions incorrectes"</span>
|h1<span style="color: #383a42; background-color: #fafafa;">::</span>t1, h2<span style="color: #383a42; background-color: #fafafa;">::</span>t2 -&gt; (h1*.h2) +. (dot t1 t2)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org6d64052" class="outline-2">
<h2 id="org6d64052">PGCD et PPCM&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rec">rec</span></span></h2>
<div class="outline-text-2" id="text-org6d64052">
</div>
<div id="outline-container-orgf3b4e05" class="outline-3">
<h3 id="orgf3b4e05">Énoncé</h3>
<div class="outline-text-3" id="text-orgf3b4e05">
<p>
Implémentez une fonction <code>gcd_and_lcm</code> qui s&rsquo;évalue en le couple du PGCD et PPCM des deux entiers passés en argument.
</p>

<p>
Par exemple <code>gcd_and_lcm 15 9</code> s&rsquo;évalue en <code>(3,45)</code>.
</p>
</div>
</div>
<div id="outline-container-org4bfe306" class="outline-3 spoiler">
<h3 id="org4bfe306">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org4bfe306">
<p>
On commence par implémenter une fonction qui calcule le PGCD de deux nombres. Pour cela on procède de manière récursive via la relation <code>gcd a b = gcd b (a mod b)</code> et <code>gcd a 0 = a</code> (algorithme d&rsquo;Euclide).
</p>

<p>
Ensuite on se sert de la relation <code>(gcd a b) × (lcm a b) = a×b</code>
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">gcd</span> <span style="color: #6a1868;">a</span> <span style="color: #6a1868;">b</span> =
  <span style="color: #e45649;">if</span> b = <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #e45649;">then</span>
    a
  <span style="color: #e45649;">else</span>
    gcd b (a <span style="color: #a52a2a;">mod</span> b)

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">gcd_and_lcm</span> <span style="color: #6a1868;">a</span> <span style="color: #6a1868;">b</span> =
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">gcd_ab</span> = gcd a b <span style="color: #000000; font-weight: bold;">in</span>
  (gcd_ab, a*b / gcd_ab)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org735ad4f" class="outline-2">
<h2 id="org735ad4f">Insertion dans un Arbre Binaire de recherche&#xa0;&#xa0;&#xa0;<span class="tag"><span class="type_rec">type_rec</span></span></h2>
<div class="outline-text-2" id="text-org735ad4f">
</div>
<div id="outline-container-org1265876" class="outline-3">
<h3 id="org1265876">Énoncé</h3>
<div class="outline-text-3" id="text-org1265876">
<p>
On s&rsquo;intéresse à une implémentation des arbres binaires de recherche à l&rsquo;aide d&rsquo;un type récursif dont le constructeur pour un arbre vide est nommé <code>Empty</code> et le constructeur pour un noeud est nommé <code>Node</code> et prend un triplet (fils gauche, (couple clé, valeur), fils droit) en paramètre.
Implémentez le type récursif <code>abr</code> correspondant, les clés seront des <code>string</code> et les valeurs de <code>int</code>.
</p>

<p>
Implémentez une fonction <code>abr_insert</code> qui insère à la bonne place une valeur <code>v</code> associée à une clé <code>k</code> dans un ABR <code>t</code>. Si <code>k</code> est déjà dans l&rsquo;ABR, on remplacera la valeur associée.
</p>

<p>
Par exemple
</p>
<div class="org-src-container">
<pre class="src src-ocaml">abr_insert <span style="color: #50a14f;">"key"</span> <span style="color: #da8548; font-weight: bold;">2</span> (<span style="color: #383a42; background-color: #fafafa;">Node</span> (
                        <span style="color: #383a42; background-color: #fafafa;">Node</span> (<span style="color: #383a42; background-color: #fafafa;">Empty</span>, (<span style="color: #50a14f;">"hey"</span>, <span style="color: #da8548; font-weight: bold;">0</span>), <span style="color: #383a42; background-color: #fafafa;">Empty</span>),
                        (<span style="color: #50a14f;">"jey"</span>,<span style="color: #da8548; font-weight: bold;">1</span>),
                        <span style="color: #383a42; background-color: #fafafa;">Empty</span>))
</pre>
</div>
<p>
s&rsquo;évaluera en:
</p>
<div class="org-src-container">
<pre class="src src-ocaml">(<span style="color: #383a42; background-color: #fafafa;">Node</span> (
     <span style="color: #383a42; background-color: #fafafa;">Node</span> (<span style="color: #383a42; background-color: #fafafa;">Empty</span>, (<span style="color: #50a14f;">"hey"</span>, <span style="color: #da8548; font-weight: bold;">0</span>), <span style="color: #383a42; background-color: #fafafa;">Empty</span>),
     (<span style="color: #50a14f;">"jey"</span>,<span style="color: #da8548; font-weight: bold;">1</span>),
     (<span style="color: #383a42; background-color: #fafafa;">Node</span> (<span style="color: #383a42; background-color: #fafafa;">Empty</span>, (<span style="color: #50a14f;">"key"</span>,<span style="color: #da8548; font-weight: bold;">2</span>),<span style="color: #383a42; background-color: #fafafa;">Empty</span>))))
</pre>
</div>
</div>
</div>
<div id="outline-container-org35f1f03" class="outline-3 spoiler">
<h3 id="org35f1f03">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org35f1f03">
<p>
On commence par implémenter le type de demandé.
</p>

<p>
Ensuite, il s&rsquo;agit de faire un parcours récursif de l&rsquo;arbre en descendant à gauche ou à droite selon la manière dont la valeur du noeud courant se compare à l&rsquo;élément recherché.
</p>

<p>
En arrivant sur un arbre vide, on insère le couple avec deux arbres vides comme enfants.
Si jamais on trouve la clé dans l&rsquo;arbre pendant la recherche de la bonne place, on remplace la valeur associée.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #986801;">abr</span> = <span style="color: #383a42; background-color: #fafafa;">Empty</span> | <span style="color: #383a42; background-color: #fafafa;">Node</span> <span style="color: #e45649;">of</span> abr * (string * int) * abr

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">abr_insert</span> <span style="color: #6a1868;">key</span> <span style="color: #6a1868;">value</span> <span style="color: #6a1868;">t</span> =
  <span style="color: #e45649;">match</span> t <span style="color: #e45649;">with</span>
  |<span style="color: #383a42; background-color: #fafafa;">Empty</span> -&gt; <span style="color: #383a42; background-color: #fafafa;">Node</span> (<span style="color: #383a42; background-color: #fafafa;">Empty</span>, (key, value), <span style="color: #383a42; background-color: #fafafa;">Empty</span>)
  |<span style="color: #383a42; background-color: #fafafa;">Node</span> (l, (k,v), r) <span style="color: #e45649;">when</span> k = key -&gt;
    <span style="color: #383a42; background-color: #fafafa;">Node</span> (l, (key,value), r)
  |<span style="color: #383a42; background-color: #fafafa;">Node</span> (l, (k,v), r) <span style="color: #e45649;">when</span> k &gt; key -&gt;
    <span style="color: #383a42; background-color: #fafafa;">Node</span> (abr_insert key value l, (k,v), r)
  |<span style="color: #383a42; background-color: #fafafa;">Node</span> (l, (k,v), r) <span style="color: #9ca0a4;">(*</span><span style="color: #9ca0a4;">k &gt; key</span><span style="color: #9ca0a4;">*)</span> -&gt;
    <span style="color: #383a42; background-color: #fafafa;">Node</span> (l, (k,v), abr_insert key value r)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org42e2b91" class="outline-2">
<h2 id="org42e2b91">Rotation de matrice&#xa0;&#xa0;&#xa0;<span class="tag"><span class="imp_ratif">impératif</span>&#xa0;<span class="matrice">matrice</span></span></h2>
<div class="outline-text-2" id="text-org42e2b91">
</div>
<div id="outline-container-orga73338e" class="outline-3">
<h3 id="orga73338e">Énoncé</h3>
<div class="outline-text-3" id="text-orga73338e">
<p>
Implémentez une fonction <code>matrix_turn</code> qui prend en argument une matrice carrée et s&rsquo;évalue en cette matrice tournée d&rsquo;un quart de tour dans le sens positif.
</p>

<p>
Par exemple <code>matrix_turn [|[|1;2;3|];[|4;5;6|];[|7;8;9|]|]</code> s&rsquo;évalue en <code>[|[|3;6;9|];[|2;5;8|];[|1;4;7|]|]</code>
</p>
</div>
</div>
<div id="outline-container-org35d359e" class="outline-3 spoiler">
<h3 id="org35d359e">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org35d359e">
<p>
Pour faire cette rotation, on peut se rendre compte que le coefficient <code>i,j</code> est remplacé par <code>j, n-1-i</code>.
</p>

<p>
Afin de ne pas modifier la matrice initiale, il faut créer une matrice de dimension égales à l&rsquo;aide de <code>Array.make_matrix</code>.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">matrix_turn</span> <span style="color: #6a1868;">m</span> =
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">l</span> = <span style="color: #986801;">Array.</span>length m <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">c</span> = <span style="color: #986801;">Array.</span>length m.(<span style="color: #da8548; font-weight: bold;">0</span>) <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #e45649;">if</span> l &lt;&gt; c <span style="color: #e45649;">then</span>
    <span style="color: #a626a4;">failwith</span> <span style="color: #50a14f;">"Matrice non carr&#233;e"</span>
  <span style="color: #e45649;">else</span>
    <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">n</span> = c <span style="color: #000000; font-weight: bold;">in</span>
    <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">result</span> = <span style="color: #986801;">Array.</span>make_matrix l c m.(<span style="color: #da8548; font-weight: bold;">0</span>).(<span style="color: #da8548; font-weight: bold;">0</span>) <span style="color: #000000; font-weight: bold;">in</span>
    <span style="color: #e45649;">for</span> i = <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #e45649;">to</span> n-<span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #e45649;">do</span>
      <span style="color: #e45649;">for</span> j = <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #e45649;">to</span> n -<span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #e45649;">do</span>
        result.(i).(j) &lt;- m.(j).(n-<span style="color: #da8548; font-weight: bold;">1</span>-i)
      <span style="color: #e45649;">done</span>
    <span style="color: #e45649;">done</span>;
    result
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org1783ffd" class="outline-2">
<h2 id="org1783ffd">Subset sum&#xa0;&#xa0;&#xa0;<span class="tag"><span class="rec">rec</span>&#xa0;<span class="liste">liste</span></span></h2>
<div class="outline-text-2" id="text-org1783ffd">
</div>
<div id="outline-container-org2d4525d" class="outline-3">
<h3 id="org2d4525d">Énoncé</h3>
<div class="outline-text-3" id="text-org2d4525d">
<p>
On s&rsquo;intéresse au problème suivant: étant donné une liste <code>lst</code> d&rsquo;entiers positifs et un entier positifs <code>n</code>, est-il possible de trouver un ensemble d&rsquo;éléments de <code>lst</code> dont la somme est <code>n</code> ?
Implémentez une fonction <code>subset_sum</code> qui renvoie la liste des éléments de <code>lst</code> qui somment à <code>n</code> si elle existe. Vous utiliserez un type option pour gérez le cas où une telle liste n&rsquo;existe pas.
</p>

<p>
Par exemple <code>subset_sum 6 [1;2;3;4;5]</code> s&rsquo;évalue en <code>Some [2;4]</code> (même si on pourrait aussi avoir <code>Some [1;5]</code>).
</p>

<p>
Quelle est la complexité d&rsquo;une telle fonction par rapport au nombre d&rsquo;éléments de la liste ? Comment pourrait-on améliorer cette complexité ?
</p>
</div>
</div>
<div id="outline-container-org2514635" class="outline-3 spoiler">
<h3 id="org2514635">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org2514635">
<p>
On s&rsquo;appuie sur la disjonction de cas suivante: si <code>lst = head::tail</code> alors on peut obtenir n avec les élément de lst dans deux cas:
</p>
<ul class="org-ul">
<li>Si on peut obtenir <code>n</code> uniquement avec les éléments de <code>tail</code></li>
<li>Si on peut obtenir <code>n-head</code> avec uniquement les éléments de <code>tail</code></li>
</ul>
<p>
Ceci donne donc une relation de récurrence, sachant que la seule valeur qu&rsquo;on peut faire avec la liste vide est 0 et qu&rsquo;aucune liste ne peut faire une valeur négative.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a626a4;">subset_sum</span> <span style="color: #6a1868;">n</span> <span style="color: #6a1868;">lst</span> =
  <span style="color: #e45649;">match</span> n,lst <span style="color: #e45649;">with</span>
  |n, _ <span style="color: #e45649;">when</span> n &lt; <span style="color: #da8548; font-weight: bold;">0</span> -&gt; <span style="color: #383a42; background-color: #fafafa;">None</span>
  |<span style="color: #da8548; font-weight: bold;">0</span>,<span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; <span style="color: #383a42; background-color: #fafafa;">Some</span> <span style="color: #383a42; background-color: #fafafa;">[]</span>
  |_,<span style="color: #383a42; background-color: #fafafa;">[]</span> -&gt; <span style="color: #383a42; background-color: #fafafa;">None</span>
  |n,head<span style="color: #383a42; background-color: #fafafa;">::</span>tail -&gt; (
    <span style="color: #e45649;">match</span> subset_sum n tail, subset_sum (n-head) tail <span style="color: #e45649;">with</span>
    |<span style="color: #383a42; background-color: #fafafa;">None</span>, <span style="color: #383a42; background-color: #fafafa;">None</span> -&gt; <span style="color: #383a42; background-color: #fafafa;">None</span>
    |<span style="color: #383a42; background-color: #fafafa;">Some</span> lst_full, _ -&gt; <span style="color: #383a42; background-color: #fafafa;">Some</span> lst_full
    |_, <span style="color: #383a42; background-color: #fafafa;">Some</span> lst_no_head-&gt; <span style="color: #383a42; background-color: #fafafa;">Some</span> (head<span style="color: #383a42; background-color: #fafafa;">::</span>lst_no_head)
    )
</pre>
</div>
<p>
La complexité est exponentielle en la taille de la liste dans le pire cas. On pourrait utiliser une approche avec mémoïsation pour réduire cette complexité.
</p>
</div>
</div>
</div>
<div id="outline-container-org55afcba" class="outline-2">
<h2 id="org55afcba">Position du plus grand mot&#xa0;&#xa0;&#xa0;<span class="tag"><span class="imp_rarif">impérarif</span>&#xa0;<span class="r_f_rence">référence</span></span></h2>
<div class="outline-text-2" id="text-org55afcba">
</div>
<div id="outline-container-orgc1fdd52" class="outline-3">
<h3 id="orgc1fdd52">Énoncé</h3>
<div class="outline-text-3" id="text-orgc1fdd52">
<p>
On considère une chaîne de caractères constituée uniquement de lettre et d&rsquo;espaces.
Implémentez une fonction <code>search_largest_word</code> qui s&rsquo;évalue en la position de début et de fin du mot le plus long de cette chaîne.
</p>

<p>
Par exemple <code>search_largest_word "ceci est une phrase vide"</code> s&rsquo;évalue en <code>(13,18)</code>.
</p>
</div>
</div>
<div id="outline-container-org3162c6d" class="outline-3 spoiler">
<h3 id="org3162c6d">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-org3162c6d">
<p>
On va parcourir toute la chaîne en gardant en mémoire les meilleurs indices de début et de fin en plus des indices courants de début et de fin de mot. Quand on tombe sur un espace, on compare la longueur du mot et on met éventuellement à jour les meilleurs indices.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">search_largest_word</span> <span style="color: #6a1868;">t</span> =
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">best_start</span> = <span style="color: #a626a4;">ref</span> <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">best_end</span> = <span style="color: #a626a4;">ref</span> <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">current_start</span> = <span style="color: #a626a4;">ref</span> <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">current_end</span> = <span style="color: #a626a4;">ref</span> <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #e45649;">for</span> i = <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #e45649;">to</span> (<span style="color: #986801;">String.</span>length t) -<span style="color: #da8548; font-weight: bold;">1</span> <span style="color: #e45649;">do</span>
    <span style="color: #e45649;">if</span> t.[i] = <span style="color: #50a14f;">' '</span> <span style="color: #e45649;">then</span>
      (
        current_end := i-<span style="color: #da8548; font-weight: bold;">1</span>;
        (<span style="color: #e45649;">if</span> <span style="color: #a52a2a;">!</span>current_end - <span style="color: #a52a2a;">!</span>current_start &gt; <span style="color: #a52a2a;">!</span>best_end - <span style="color: #a52a2a;">!</span>best_start <span style="color: #e45649;">then</span>
          (
            best_end := <span style="color: #a52a2a;">!</span>current_end;
            best_start := <span style="color: #a52a2a;">!</span>current_start;
          )
        );
        current_start := i+<span style="color: #da8548; font-weight: bold;">1</span>;
      )
  <span style="color: #e45649;">done</span>;
  current_end := (<span style="color: #986801;">String.</span>length t) -<span style="color: #da8548; font-weight: bold;">1</span>;
  (<span style="color: #e45649;">if</span> <span style="color: #a52a2a;">!</span>current_end - <span style="color: #a52a2a;">!</span>current_start &gt; <span style="color: #a52a2a;">!</span>best_end - <span style="color: #a52a2a;">!</span>best_start <span style="color: #e45649;">then</span>
     (
       best_end := <span style="color: #a52a2a;">!</span>current_end;
       best_start := <span style="color: #a52a2a;">!</span>current_start;
     )
  );
  (<span style="color: #a52a2a;">!</span>best_start, <span style="color: #a52a2a;">!</span>best_end)

</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org3200a2a" class="outline-2">
<h2 id="org3200a2a">Palindrome&#xa0;&#xa0;&#xa0;<span class="tag"><span class="imp_ratif">impératif</span>&#xa0;<span class="r_f_rence">référence</span></span></h2>
<div class="outline-text-2" id="text-org3200a2a">
</div>
<div id="outline-container-orgf7c1d9f" class="outline-3">
<h3 id="orgf7c1d9f">Énoncé</h3>
<div class="outline-text-3" id="text-orgf7c1d9f">
<p>
Implémentez une fonction <code>is_palindrome</code> qui s&rsquo;évalue en <code>true</code> si la chaîne passée en argument est un palindrome et <code>false</code> autrement. Les espaces seront ignorés.
</p>

<p>
Par exemple <code>is_palindrome "ab ce cba"</code> s&rsquo;évalue en <code>true</code>.
</p>
</div>
</div>
<div id="outline-container-orgeb6677c" class="outline-3 spoiler">
<h3 id="orgeb6677c">Corrigé&#xa0;&#xa0;&#xa0;<span class="tag"><span class="corrige">corrige</span></span></h3>
<div class="outline-text-3" id="text-orgeb6677c">
<p>
Pour vérifier le caractère de palindrome, on va lire le mot depuis le début et la fin simultanément. Pour cela on introduit deux références correspondant à la position du curseur et début et fin de mot. Quand on rencontre un espace, on fait avancer les curseurs jusqu&rsquo;à la prochaine lettre.
Quand on rencontre deux lettre identiques pour les deux curseurs, on les fait avancer aussi.
</p>

<p>
Quand les deux curseurs se rejoignent, on a terminé.
</p>

<p>
Si jamais on trouve une lettre distincte, on peut stopper le parcours.
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a626a4;">is_palindrome</span> <span style="color: #6a1868;">s</span> =
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">end_index</span> = <span style="color: #a626a4;">ref</span> ((<span style="color: #986801;">String.</span>length s) -<span style="color: #da8548; font-weight: bold;">1</span>) <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">start_index</span> = <span style="color: #a626a4;">ref</span> <span style="color: #da8548; font-weight: bold;">0</span> <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #6a1868;">no_problem_yet</span> = <span style="color: #a626a4;">ref</span> <span style="color: #b751b6;">true</span> <span style="color: #000000; font-weight: bold;">in</span>
  <span style="color: #e45649;">while</span> <span style="color: #a52a2a;">!</span>end_index &gt; <span style="color: #a52a2a;">!</span>start_index <span style="color: #a52a2a;">&amp;&amp;</span> <span style="color: #a52a2a;">!</span>no_problem_yet <span style="color: #e45649;">do</span>
    <span style="color: #e45649;">if</span> s.[<span style="color: #a52a2a;">!</span>start_index] = s.[<span style="color: #a52a2a;">!</span>end_index] <span style="color: #e45649;">then</span>
       <span style="color: #9ca0a4;">(* </span><span style="color: #9ca0a4;">Si les lettres sont identiques,</span><span style="color: #9ca0a4;"> *)</span>
       <span style="color: #9ca0a4;">(* </span><span style="color: #9ca0a4;">espace ou non, on peut progresser</span><span style="color: #9ca0a4;"> *)</span>
       (
         start_index := <span style="color: #a52a2a;">!</span>start_index + <span style="color: #da8548; font-weight: bold;">1</span>;
         end_index := <span style="color: #a52a2a;">!</span>end_index - <span style="color: #da8548; font-weight: bold;">1</span>
       )
    <span style="color: #e45649;">else</span> <span style="color: #e45649;">if</span> s.[<span style="color: #a52a2a;">!</span>start_index] = <span style="color: #50a14f;">' '</span> <span style="color: #e45649;">then</span>
      start_index := <span style="color: #a52a2a;">!</span>start_index + <span style="color: #da8548; font-weight: bold;">1</span>
    <span style="color: #e45649;">else</span> <span style="color: #e45649;">if</span> s.[<span style="color: #a52a2a;">!</span>end_index] = <span style="color: #50a14f;">' '</span> <span style="color: #e45649;">then</span>
      end_index := <span style="color: #a52a2a;">!</span>end_index - <span style="color: #da8548; font-weight: bold;">1</span>
    <span style="color: #e45649;">else</span> <span style="color: #9ca0a4;">(*</span><span style="color: #9ca0a4;">s.[!start_index] &lt;&gt; s.[!end_index]</span><span style="color: #9ca0a4;">*)</span>
        no_problem_yet := <span style="color: #b751b6;">false</span>;
  <span style="color: #e45649;">done</span>;
  <span style="color: #a52a2a;">!</span>no_problem_yet
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org8968dbd" class="outline-2">
<h2 id="org8968dbd">Remerciements</h2>
<div class="outline-text-2" id="text-org8968dbd">
<p>
Merci à J.Reichert pour ses nombreuses idées d&rsquo;exercice.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
Vladislav Tempez, 2024-09-09 Mon 16:42
</div>
</body>
</html>
